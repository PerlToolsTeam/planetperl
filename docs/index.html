<!DOCTYPE html>
<html>
  <head>
    <meta property="og:title" content="Planet Perl" /> 
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://perl.theplanetarium.org/" />
    <meta property="og:image" content="https://perl.theplanetarium.org/planet-perl.jpg" />
    <meta property="og:description" content="Collecting the best Perl web feeds"/>
    <title>Planet Perl</title>
    <meta charset="UTF-8">
    <!-- Bootstrap core CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css"
          integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z"
          crossorigin="anonymous">

    <link rel="alternate" type="application/atom+xml" title="Atom" href="http://perl.theplanetarium.org/atom.xml" />
    <link rel="stylesheet" type="text/css" href="/css/style.css">
    <script src="https://use.fontawesome.com/releases/v5.13.0/js/all.js" crossorigin="anonymous"></script>
  </head>
  <body>
    <nav class="navbar fixed-top navbar-dark bg-dark">
      <a class="navbar-brand" href="#">Planet Perl</a>
    </nav>
    <div class="container-fluid">
      <div class="row">
        <div class="col-md-2 left">
          <p>Text: <a href="#" id="show">show</a> / <a href="#" id="hide">hide</a></p>
          <h2>Sources</h2>
          <ul>
            <li><a href="http://blogs.perl.org/">blogs.perl.org</a></li>
            <li><a href="https://dev.to/t/perl">dev.to #perl</a></li>
            <li><a href="https://domm.plix.at/perl.html">domm (Perl and other tech)</a></li>
            <li><a href="https://www.endpointdev.com/blog/tags/perl/">End Point Dev blog Perl topic</a></li>
            <li><a href="https://metacpan.org/news">MetaCPAN News</a></li>
            <li><a href="https://niceperl.blogspot.com/">Niceperl</a></li>
            <li><a href="https://nxadm.wordpress.com/tag/perl/">nxadm</a></li>
            <li><a href="https://news.perlfoundation.org/">Perl Foundation News</a></li>
            <li><a href="https://perlhacks.com/">Perl Hacks</a></li>
            <li><a href="https://perlmaven.com/">Perl Maven</a></li>
            <li><a href="https://perlweekly.com/">Perl Weekly</a></li>
            <li><a href="https://blog.perl-academy.de/">Perl-Academy.de</a></li>
            <li><a href="https://perl.com/">perl.com</a></li>
            <li><a href="https://perlancar.wordpress.com/">Perlancar</a></li>
            <li><a href="http://www.rabbitfarm.com/cgi-bin/blosxom/perl">RabbitFarm Perl</a></li>
            <li><a href="https://log.perl.org/">The Perl NOC</a></li>
            <li><a href="https://theweeklychallenge.org/blog/">The Weekly Challenge</a></li>
          </ul>
          <p><a href="/atom.xml"><img alt="Feed" src="/images/feed.gif" /> Subscribe</a>
          <br />
          <a href="/opml.xml"><img alt="OPML" src="/images/opml.png" /> OPML</a></p>
          <p>
            <ul>
              <li>Powered by <a href="https://metacpan.org/release/Perlanet">Perlanet</a></li>
              <li>Code on <a href="https://github.com/davorg/planetperl">Github</a></li>
              <li><a href="https://github.com/davorg/planetperl/issues">Feedback welcome</a></li>
            </ul>
          </p>
        </div><!-- col-md-2 -->
        <div class="col-md-8">
          <div class="card" id="card_1">
            <div class="card-header">
              <h2 class="card-title"><a href="http://www.rabbitfarm.com/cgi-bin/blosxom/2022/07/17#pwc173">Suffering Succotash!</a></h2>
<a href="http://www.rabbitfarm.com/cgi-bin/blosxom/perl" class="badge badge-primary" style="float: left">RabbitFarm Perl</a>

              <p class="text-right"><small>Published
 on Sunday 17 July 2022 21:30</small></p>
            </div> <!-- card-header -->
     <div class="card-body">       <div class="card-text">
<p><em>The examples used here are from the weekly challenge problem statement and demonstrate 
the working solution.</em></p>

<h2>Part 1</h2>

<p><em>You are given a positive integer, $n. Write a script to find out if the given number is 
an Esthetic Number.</em></p>

<h3>Solution</h3>

<pre><code class="perl">
use strict;
use warnings;
use boolean;

sub is_esthetic{
    my($n) = @_;
    my @digits = split(//, $n);
    my $d0 = pop @digits;
    while(@digits){
        my $d1 = pop @digits;
        return false if abs($d1 - $d0) != 1;
        $d0 = $d1;
    }
    return true;
}

MAIN:{
    my $n;
    $n = 5456;
    print "$n is ";
    print "esthetic\n" if is_esthetic($n);
    print "not esthetic\n" if !is_esthetic($n);
    $n = 120; 
    print "$n is ";
    print "esthetic\n" if is_esthetic($n);
    print "not esthetic\n" if !is_esthetic($n);
}
</code></pre>

<h3>Sample Run</h3>

<pre><code class="shell">
$ perl perl/ch-1.pl
5456 is esthetic
120 is not esthetic
</code></pre>

<h3>Notes</h3>

<p>I started to write this solution and then kept coming back to it, considering if there is
a more elegant approach. If there is I could not come up with it on my own over this past 
week! This doesn't seem all that bad, just a bit "mechanical" perhaps?</p>

<ol>
<li>Break the number into an array of digits
</li>
<li>Do a pairwise comparison of successive digits by popping them off the array one at a 
time and retaining the most recently popped digit for the next iteration's comparison.
</li>
<li>If at any point the "different by 1" requirement is not met, return false.
</li>
<li>If we complete all comparisons without a failure, return true.
</li>
</ol>

<h2>Part 2</h2>

<p><em>Write a script to generate first 10 members of Sylvester's sequence.</em></p>

<h3>Solution</h3>

<pre><code class="perl">
use strict;
use warnings;
use bigint; 

sub sylvester_n{
    my($n) = @_;
    my @terms = (2, 3);
    my %product_table;
    $product_table{"2,3"} = 6;
    while(@terms < $n){
        my $term_key = join(",", @terms);
        my $term = $product_table{$term_key} + 1;
        push @terms, $term;
        $product_table{"$term_key,$term"} = $term * $product_table{$term_key}; 
    }
    return @terms;
}


MAIN:{
    print join(", ", sylvester_n(10)). "\n";
}
</code></pre>

<h3>Sample Run</h3>

<pre><code class="shell">
$ perl perl/ch-2.pl
2, 3, 7, 43, 1807, 3263443, 10650056950807, 113423713055421844361000443, 12864938683278671740537145998360961546653259485195807, 165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<h3>Notes</h3>

<p>Much like the first part I considered what might be an optimal way to compute this. Here
the standard <em>recursion and memoization</em> would be most appropriate, I believe. Just to mix
things up a little I implemented my own memoization like lookup table and computed the 
terms iteratively. Otherwise though, the effect is largely the same in that for each new
term we need not reproduce any previous multiplications.</p>

<p>These terms get large almost immediately! <code>use bigint</code> is clearly necessary here. An 
additional optimization would be the use of <code>Tie::Hash</code> and <code>Tie::Array</code> to save memory as
we compute larger and larger terms. Since TWC 173.2 only specified 10 terms I left that
unimplemented.</p>

<p>Finally, I should note that the title of this blog draws from Sylvester the Cat, not 
Sylvester the Mathematician! Sylvester the Cat's famous phrase is "Suffering Succotash!". 
See the link in the references for an example. Not everyone may not be familiar, so see 
the video link below! The comments on that video have some interesting facts about the
phrase and the character.</p>

<h2>References</h2>

<p><a href="https://theweeklychallenge.org/blog/perl-weekly-challenge-173/">Challenge 173</a></p>

<p><a href="https://www.youtube.com/watch?v=PkhPuH8G5Hg">Thufferin' thuccotash!</a></p>       </div><!-- card-text -->     </div>
            <div class="card-footer">
            </div><!-- card-footer -->
          </div><!-- card -->
          <div class="card" id="card_2">
            <div class="card-header">
              <h2 class="card-title"><a href="http://blogs.perl.org/users/laurent_r/2022/07/perl-weekly-challenge-173-sylvesters-sequence-in-dc.html">Perl Weekly Challenge 173: Sylvester's Sequence in dc</a></h2>
<a href="http://blogs.perl.org/" class="badge badge-primary" style="float: left">blogs.perl.org</a>

              <p class="text-right"><small>Published by laurent_r
 on Saturday 16 July 2022 00:25</small></p>
            </div> <!-- card-header -->
     <div class="card-body">       <div class="card-text">
        <p>This blog is an answer to the second task of the Week 173 of the <a href="https://perlweeklychallenge.org/blog/perl-weekly-challenge-173/">Perl Weekly Challenge</a> organized by <a href="http://blogs.perl.org/users/mohammad_s_anwar/">Mohammad S. Anwar</a>.</p>

<p>Originally, the Perl Weekly Challenge called for solutions in Perl and Raku (also known as Perl 6 at the time). But, very soon, people started to provide solutions in other &#8220;guest&#8221; languages. See for example <a href="http://blogs.perl.org/users/laurent_r/2022/07/perl-weekly-challenge-173-esthetic-number-and-sylvesters-sequence.html">my blog post</a> providing solutions to the Sylvester&#8217;s Sequence task described below in about 15 different guest languages.</p>

<p>One of the languages I tried is <em>dc</em>, and it turned out to be much more difficult and challenging than I initially thought. I actually spent far more time on it than I would wish to admit, at least 5 to 6 hours (not counting the time to write this blog post). One of the problems is that there is only very limited documentation on this <em>old</em> programming language. So I thought it might be useful to describe in some details how I solved it.</p>

<h2>The Task</h2>

<p><em>Write a script to generate first 10 members of Sylvester&#8217;s sequence. For more informations, please refer to the <a href="https://en.wikipedia.org/wiki/Sylvester%27s_sequence">wikipedia page</a>.</em></p>

<p><em>Output:</em></p>

<pre><code>2
3
7
43
1807
3263443
10650056950807
113423713055421844361000443
12864938683278671740537145998360961546653259485195807
165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<p>Each number in the sequence is the product of all previous numbers of the sequence plus 1.</p>

<p>A potential difficulty with this problem is that we&#8217;re dealing with very large integers, so that, for some programming languages at least, we may encounter an integer overflow error (or values may be converted to floats, with a resulting loss of precision).</p>

<h2>Sylvester&#8217;s Sequence in Some Other Languages</h2>

<p>The <em>dc</em> language is difficult and poorly documented. Before we get to it, I want to illustrate the algorithm I&#8217;ll implement with some other more traditional languages.</p>

<h3>Sylvester&#8217;s Sequence in Raku</h3>

<p>Raku&#8217;s integers support arbitrary precision, so we don&#8217;t have to worry about dealing with very large integers.</p>

<p>Our first implementation reflects directly the definition: we store the Sylvester&#8217;s sequence in the <code>@s</code> array. To get a new number, we simply compute the product of all items of the <code>@s</code> array (using the <code>[*]</code> meta-operator) and add it to the array.</p>

<pre><code>my @s = 2;
while @s.elems &lt; 10 {
    push @s, 1 + [*] @s;
}
.say for @s;
</code></pre>

<p>This program displays the following output:</p>

<pre><code>$ raku ./sylvester.raku
2
3
7
43
1807
3263443
10650056950807
113423713055421844361000443
12864938683278671740537145998360961546653259485195807
165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<p>But recomputing the full product each time is inefficient. At any time through the process, the current Sylvester number is one more than the product of all previous numbers of the sequence. For example, in the output displayed above, we can compute the number of the 4th row (43) by multiplying the number of the third row (7) by it minus 1 <code>(7 - 1)</code> and adding 1 to the product: <code>7 * (7 - 1) + 1 = 43</code>. Using this recursive definition, we can write this:</p>

<pre><code>my $n = 2;
say $n;
$n = $n * ($n - 1) + 1 and say $n for 1..^10;
</code></pre>

<p>This produces the same output:</p>

<pre><code>$ ./raku sylvester3.raku
2
3
7
43
1807
3263443
[ Lines omitted for brevity ]
</code></pre>

<p>This second implementation reflects the algorithm that we will use from now on, as it has the advantage of not using arrays to store the sequence numbers.</p>

<h3>Sylvester&#8217;s Sequence in Perl</h3>

<p>Perl doesn&#8217;t natively support large integer, but we can use the <code>use BigInt;</code> pragma to convert all numeric literals to <code>Math::BigInt</code> objects, which can store arbitrarily large integers. This Perl program is essentially identical to the second Raku implementation above:</p>

<pre><code>use strict;
use warnings;
use feature "say";
use bigint;

my $n = 2;
say $n;
$n = $n * ($n - 1) + 1 and say $n for 1..9;
</code></pre>

<p>This displays the same output as before:</p>

<pre><code> $ perl sylvester3.pl
 2
 3
 7
 43
 1807
 [ Lines omitted for brevity]
 165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<h3>Sylvester&#8217;s Sequence in bc</h3>

<p>The <a href="https://en.wikipedia.org/wiki/Bc_(programming_language">bc</a>) utility, for <em>basic calculator</em>,  is &#8220;an arbitrary-precision calculator language&#8221; with syntax similar to the C programming language. It first appeared in Version 6 Unix in 1975. It is still included nowadays in most (if not all) Linux distributions. We chose to use it because of its <em>arbitrary precision</em> feature.</p>

<pre><code>n = 2
print n, "\n"
count = 1
while (count &lt; 10) {
    n = (n - 1) * n + 1
    print n, "\n"
    count += 1
}
quit
</code></pre>

<p>This displays the same output as before:</p>

<pre><code>$ BC_LINE_LENGTH=0 bc sylvester.bc
bc 1.06.95
Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation, Inc.
This is free software with ABSOLUTELY NO WARRANTY.
For details type `warranty'.
2
3
7
43
1807
[ Lines omitted fr brevity ]
165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<p>Note that we set the <code>BC_LINE_LENGTH</code> environment variable to 0 before calling <code>bc</code> to prevent bc from cutting the last line into two chunks after 70 characters. Otherwise, it would be displayed as:</p>

<pre><code>16550664732451996419846819544443918001751315270637749784185138876653\
5868639572406808911988131737645185443
</code></pre>

<p>We will see that we&#8217;ll need to do something similar with <em>dc</em>.</p>

<p>bc was initially written as a font-end to dc. As we will see, dc performs arbitrary-precision computations specified in reverse Polish notation. At the time, bc provided a conventional programming-language interface to the same capability via a simple compiler (a single yacc source file comprising a few hundred lines of code), which converted a C-like syntax into dc notation and piped the results through dc. This is in part the reason I got interested with dc.</p>

<h2>Introducing dc</h2>

<p>According to <a href="https://en.wikipedia.org/wiki/Dc_(computer_program">Wikipedia</a>), dc (desk calculator) is a cross-platform reverse-Polish calculator which supports arbitrary-precision arithmetic. Written by Lorinda Cherry and Robert Morris at Bell Labs, it is one of the oldest Unix utilities, preceding even the invention of the C programming language. Like other utilities of that vintage, it has a powerful set of features but terse syntax. Traditionally, the bc calculator program (with infix notation) was implemented on top of dc. </p>

<p>dc is the oldest surviving Unix language program. When its home Bell Labs received a PDP-11, dc—written in B—was the first language to run on the new computer, even before an assembler.</p>

<p>It uses reverse Polish notation (RPN) which was also used around the same time by Hewlett-Packard hand calculators. RPN is a postfix notation in which you first specify the operands and then the operator. </p>

<pre><code>$ echo '5 6 + p' | dc
11
</code></pre>

<p>As you can see, we first input the two operands (5 and 6), and then the <code>+</code> operator, and finally the <code>p</code> operator to print out the result of the addition. Prefix your number with an underscore if you want to specify a negative number (e.g. <code>_5</code> for -5)</p>

<p>The spaces are not needed (except between 5 and 6) but improve readability. We could have written it this way:</p>

<pre><code>$ echo '5 6+p' | dc
11
</code></pre>

<p>dc can also be used in interactive mode:</p>

<pre><code>$ dc
5 6
+
p
11
q
</code></pre>

<p>or:</p>

<pre><code>$ dc
5 6 + p q
11
</code></pre>

<p>This can be quite convenient to test chunks of code and we will use that feature.</p>

<p>We can also use the <code>-e</code> command-line option to specify a simple program between single quotes:</p>

<pre><code>$ dc -e '5 6 + p'
11
</code></pre>

<p>dc uses a stack to perform its operations. The various commands above can be understood as follows:</p>

<pre><code>$ dc
5   # push 5 to stack
6   # push 6 to stack
f   # display stack (displays 6 and 5). Useful for debugging
6
5
+   # pop two items from stack, add them and push result to stack
p   # print top item of the stack (prints 11)
11
q   # quit
</code></pre>

<p>Note that the <code>#</code> sign indicates the beginning of a comment (the rest of the line is ignored).</p>

<p>For full details on the dc syntax, please consult the <a href="http://www.gnu.org/software/bc/manual/dc-1.05/html_mono/dc.html">dc GNU manual</a>. We will describe here only the command that we are likely to use for our program. The best tutorial I have found on dc is <a href="https://en.wikipedia.org/wiki/Dc_(computer_program">the Wikipedia dc page</a>).</p>

<h3>Printing Commands</h3>

<pre><code>p   Prints the value on the top of the stack, not altering the stack. 
n   Prints the value on the top of the stack, popping it off
f   Prints the entire contents of the stack without altering anything.
</code></pre>

<h3>Stack Control</h3>

<pre><code>c   Clears the stack, rendering it empty
d   duplicate the value on top of the stack
r   Reverses the order of (swaps) the top two values on the stack.
</code></pre>

<h3>Registers</h3>

<p>dc provides at least 256 memory registers, each named by a single character. You can store a number in a register and retrieve it later. </p>

<pre><code>sr  Pops the value off the top of the stack, stores it in register r. 
lr  Copies the value in register r, and pushes it onto the stack.
    This does not alter the contents of r.
</code></pre>

<p>Each register also contains its own stack. The current register value is the top of the register&#8217;s stack. </p>

<h3>Strings</h3>

<p>dc can operate on strings as well as on numbers. The only things you can do with strings are print them and execute them as macros (which means that the contents of the string are processed as dc commands). Both registers and the stack can hold strings, and dc always knows whether any given object is a string or a number.</p>

<pre><code>[ch] Makes a string containing "ch" and pushes it on the stack.
x   Pops the value from the top of the stack and executes it as a macro
&gt;r  Pops two values off the stack and compares them assuming they are 
    numbers, executing the contents of register r as a macro if the 
    original top-of-stack is greater
&lt;r  Similar but invokes the macro if the original top-of-stack is less
=r  Similar but invokes the macro if the original top-of-stack is equal
</code></pre>

<h3>Macros</h3>

<p>Macros are then implemented by allowing registers and stack entries to be strings as well as numbers. A string can be printed, but it can also be executed (i.e. processed as a sequence of dc commands). So for instance we can store a macro to add 3 and then multiply by 2 into register m:</p>

<pre><code>[3 + 2 *] sm
</code></pre>

<p>and then (using the <code>x</code> command which executes the top of the stack) we can use it like this:</p>

<pre><code>3 lm x p
</code></pre>

<p>This displays the following:</p>

<pre><code>$ dc -e '[3 + 2 *] sm 3 lm x p'
12
</code></pre>

<p>For better understanding, this is a detailed account of what&#8217;s going on:</p>

<pre><code>[   # start of macro definition
  3 # push 3 to stack
  + # pop 2 values off the stack, add them and store result on stack
  2 # push 2 on stack
  * # pop 2 values off the stack, multiply them, store result on stack
]   # end of macro definition
sm  # store the macro just defined in register m
3   # push 3 on stack
lm  # copy value in register m (the macro) onto the stack
x   # run the macro
p   # print the result (top of the stack)
</code></pre>

<p>We will look at conditionals and loops later on.</p>

<h2>Sylvester&#8217;s Sequence in dc</h2>

<p>Let&#8217;s now try to implement Sylvester&#8217;s sequence in dc.</p>

<h3>Implementing the Basic Formula</h3>

<p>Remember that we want to do something equivalent to this Raku program:</p>

<pre><code>my $n = 2;
say $n;
$n = $n * ($n - 1) + 1 and say $n for 1..^10;
</code></pre>

<p>We will do it mostly in interactive mode.</p>

<p>First, we want to give an initial value of 2 to n and print it.</p>

<pre><code>$ dc
2snlnp
2
</code></pre>

<p>This is a detailed description of the cryptic <code>2snlnp</code> command:</p>

<pre><code>2    # push 2 on stack
sn   # pops 2 from stack and store in register n
ln   # copy register n onto stack
p    # print top of stack
</code></pre>

<p>We could make it one character shorter by using the <code>d</code> duplicate command:</p>

<pre><code>$ dc -e '2dsnp'
2
</code></pre>

<p>Then, we want to implement and test the <code>$n = $n * ($n - 1) + 1</code> formula:</p>

<pre><code>2snlnp
2
1-   # subtract 1 from stack
ln   # load n on stack
*1+p # compute product, add 1 and print new value
3    
sn   # pop new value and store it in register n
ln   # copy new value in n to stack
</code></pre>

<p>So, <code>n</code> was 2 and is now set to 3. This is the expected result, so it looks promising. Let&#8217;s run again that series of commands a couple of times:</p>

<pre><code>$ dc
2snlnp
2
1-   # subtract 1 from stack
ln   # load n on stack
*1+p # compute product, add 1 and print new value
3
sn   # pop new value and store it in register n
ln   # copy new value in n to stack
1-   # subtract 1 from stack
ln   # load n on stack
*1+p # compute product, add 1 and print new value
7
sn   # pop new value and store it in register n
ln   # copy new value in n to stack
1-   # subtract 1 from stack
ln   # load n on stack
*1+p # compute product, add 1 and print new value
43
sn   # pop new value and store it in register n
ln   # copy new value in n to stack
1-   # subtract 1 from stack
ln   # load n on stack
*1+p # compute product, add 1 and print new value
1807
</code></pre>

<p>We obtain the proper sequence of Sylvester numbers: 2, 3, 7, 43, 1807. But, of course, it is a pain in the neck to repeatedly enter this series of 5 commands. We can store it in a macro (I used register <code>m</code>, m as the first letter in macro, because it makes it easier to remember, but you could store a macro in any other register) and then execute the macro any number of times:</p>

<pre><code>$ dc
2snlnp                 # initialization of n to 2
2
[1- ln *1+p sn ln]sm   # store the macro in register m
lm x                   # run the macro
3
lm x
7
lm x
43
lm x
1807
lm x
3263443
lm x
10650056950807
...
</code></pre>

<p>So, the results are correct, we have the basic actions to compute the Sylvester&#8217;s sequence. We still have to implement a loop to automatize macro execution a given number of times.</p>

<h3>Conditionals and Loops in dc</h3>

<p>The <code>=</code>, <code>&gt;</code>, <code>!&gt;</code>, <code>&lt;</code>, <code>!&lt;</code>, <code>!=</code> conditionals execute the subsequent macro when the two top values of the stack are equal, larger than, not larger than, etc. For example, in:</p>

<pre><code>$ dc -e '[[smaller than]p] sm 6 5 &lt;m'
smaller than
</code></pre>

<p>the macro stored in <code>m</code> runs (and prints &#8220;smaller than&#8221;) because 5 is smaller than 6. The <code>&lt;</code> pops 5 and then 6 from the stack and runs the macro in register <code>m</code> because the first popped value (5) is smaller than the second popped value.</p>

<p>The above-mentioned Wikipedia page then states: &#8220;Looping is then possible by defining a macro which (conditionally) reinvokes itself. A simple factorial of the top of the stack might be implemented as: </p>

<pre><code>[d1-d1&lt;F*]dsFxp
</code></pre>

<p>I must admit that I did not understand it when I first read it. And still not when I read it a second time and then a third time.</p>

<p>Let&#8217;s get away from the Sylvester sequence for a brief moment and look at a simple countdown in <a href="https://wiki.bash-hackers.org/howto/calculate-dc">this page</a> in the Bash Hackers Wiki:</p>

<pre><code>dc &lt;&lt; EOF
[ li       # put our index i on the stack 
  p        # print it, to see what's going on
  1 -      # we decrement the index by one
  si       # store decremented index (i=i-1)
 0 li &gt;L   # if i &gt; 0 then execute L
] sL       # store our macro with the name L
10 si      # let's give to our index the value 10
lLx        # and start our loop
EOF 

10
9
8
[ lines omitted for brevity]
2
1
</code></pre>

<p>OK, now I understand it (and I suppose you will if you read the detailed comments) and can complete the task. Basically, the macro is called a first time, and then calls itself recursively so long as the condition is satisfied.</p>

<h3>The Complete Sylvester Program in dc</h3>

<p>This is now the full Sylvester&#8217;s sequence program in dc:</p>

<pre><code>2sn     # push 2 on the stack, pop 2 off the top of the stack
        # and store it into register n
lnp     # copy the value back on the stack and print it
9sc     # give counter c an initial value of 9
[       # start of macro
  1-    # subtract 1 from stack (value n-1)
  ln    # load n to stack
  *1+p  # compute product n * n-1, add 1 and print
  sn    # pop new value and store it in register n
  ln    # copy new value in  n to stack
  lc    # copy counter to stack
  1-    # decrement counter (subtract 1 from c)
  sc    # store decremented counter in c
  0 lc  # store 0 and counter on stack
  &gt;m    # compare c to 0 and, if c &gt; 0, run recursively macro in m
]       # end of macro
d       # duplicate macro on stack
sm      # store macro in register m
x       # execute first iteration of macro
</code></pre>

<p>To run it and display properly the last line, we need to set the <code>DC_LINE_LENGTH</code> to 0 in a way similar to what we had to do with bc.</p>

<pre><code>$  DC_LINE_LENGTH=0 dc sylvester.dc
2
3
7
43
1807
3263443
10650056950807
113423713055421844361000443
12864938683278671740537145998360961546653259485195807
165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<p>But, of course, formatting the program with spaces and comments as above is way too easy and good only for wimps and cowards. Real programmers will prefer this one-line version ( <code>;-)</code>):</p>

<pre><code>2snlnp9sc[1-ln*1+psnlnlc1-sc0lc&gt;m]dsmx
</code></pre>

<p>which you can run as follows:</p>

<pre><code>$ echo '2snlnp9sc[1-ln*1+psnlnlc1-sc0lc&gt;m]dsmx
       ' |  DC_LINE_LENGTH=0 dc
2
3
7
43
1807
3263443
10650056950807
113423713055421844361000443
12864938683278671740537145998360961546653259485195807
165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<h2>Wrapping up</h2>

<p>The next week Perl Weekly Challenge will start soon. If you want to participate in this challenge, please check https://perlweeklychallenge.org/ and make sure you answer the challenge before 23:59 BST (British summer time) on July 24, 2022. And, please, also spread the word about the Perl Weekly Challenge if you can.</p>

        

           </div><!-- card-text -->     </div>
            <div class="card-footer">
            </div><!-- card-footer -->
          </div><!-- card -->
          <div class="card" id="card_3">
            <div class="card-header">
              <h2 class="card-title"><a href="http://blogs.perl.org/users/laurent_r/2022/07/perl-weekly-challenge-173-esthetic-number-and-sylvesters-sequence.html">Perl Weekly Challenge 173: Esthetic Number and Sylvester's Sequence</a></h2>
<a href="http://blogs.perl.org/" class="badge badge-primary" style="float: left">blogs.perl.org</a>

              <p class="text-right"><small>Published by laurent_r
 on Monday 11 July 2022 19:08</small></p>
            </div> <!-- card-header -->
     <div class="card-body">       <div class="card-text">
        <p>These are some answers to the Week 173 of the <a href="https://perlweeklychallenge.org/blog/perl-weekly-challenge-173/">Perl Weekly Challenge</a> organized by <a href="http://blogs.perl.org/users/mohammad_s_anwar/">Mohammad S. Anwar</a>.</p>

<p><em>Spoiler Alert:</em> This weekly challenge deadline is due in a few of days from now (on July 17, 2022 at 23:59). This blog post offers some solutions to this challenge, please don’t read on if you intend to complete the challenge on your own.</p>

<h2>Task 1: Esthetic Number</h2>

<p><em>You are given a positive integer, <code>$n</code>.</em></p>

<p><em>Write a script to find out if the given number is Esthetic Number.</em></p>

<blockquote>
  <p><em>An esthetic number is a positive integer where every adjacent digit differs from its neighbour by 1.</em></p>
</blockquote>

<p><em>For example,</em></p>

<pre><code>5456 is an esthetic number as |5 - 4| = |4 - 5| = |5 - 6| = 1
120 is not an esthetic numner as |1 - 2| != |2 - 0| != 1
</code></pre>

<h3>Esthetic Number in Raku</h3>

<p>We write an <code>is-esthetic</code> subroutine which splits the input number into an array of digits and checks, for each digit, whether the absolute value of its difference with the previous one is equal to 1. The subroutine returns <code>False</code> is this value is not 1. If it loops through the end, it returns True.</p>

<pre><code>sub is-esthetic ($n) {
    my @d = $n.comb;     # get an array of digits
    return False if abs(@d[$_] - @d[$_-1]) != 1 for 1..@d.end;
    return True;
}
for &lt;5456 120 121 23456 2346 7654567 765467&gt; -&gt; $test {
    say $test.fmt("%-9d"), is-esthetic($test) ?? "is esthetic" !! "is not esthetic";
}
</code></pre>

<p>This program displays the following output:</p>

<pre><code>$ raku ./esthetic_nums.raku
5456     is esthetic
120      is not esthetic
121      is esthetic
23456    is esthetic
2346     is not esthetic
7654567  is esthetic
765467   is not esthetic
</code></pre>

<h3>Esthetic Number in Perl</h3>

<p>This is a port to Perl of the previous Raku program, with an <code>is_esthetic</code> subroutine returning 0 (false value) if the absolute value of the difference between two adjacent digits is not equal to 1.</p>

<pre><code>use strict;
use warnings;
use feature "say";

sub is_esthetic {
    my @d = split //, shift;     # get an array of digits
    for my $i (1..$#d) {
        return 0 if abs($d[$i] - $d[$i -1 ]) != 1;
    }
    return 1;
}
for my $test (qw&lt;5456 120 121 23456 2346 7654567 765467&gt;) {
    say sprintf("%-9d", $test), is_esthetic($test) ? "is esthetic" : "is not esthetic";
}
</code></pre>

<p>This program displays the following output:</p>

<pre><code>$ perl ./esthetic_nums.pl
5456     is esthetic
120      is not esthetic
121      is esthetic
23456    is esthetic
2346     is not esthetic
7654567  is esthetic
765467   is not esthetic
</code></pre>

<h3>Esthetic Number in Julia</h3>

<p>In Julia, you can use subscripts to access individual characters of a string:</p>

<pre><code>julia&gt; print("hello World"[5])    # Scala subscripts start at 1
o
</code></pre>

<p>You cannot do that in Perl and in Raku. Well, in Raku, you could implement your own postcircumfix <code>[...]</code> operator like this:</p>

<pre><code>multi sub postcircumfix:&lt;[ ]&gt; (Str $s, Int $n) {
    substr-rw $s, $n, 1;
}
</code></pre>

<p>but it doesn&#8217;t seem to be worth the trouble for such a simple program.</p>

<p>Anyway since subscript can be used for that purpose in Scala, I decided that my program could easily traverse the string representation of the candidate number, without having to split it into an array of individual digits. All we need to do is to coerce the input number into a string.</p>

<pre><code>function is_esthetic(num)
    n = string(num)
    for i in 2:length(n)
        if abs(n[i] - n[i-1]) != 1
            return false
        end
    end
    return true
end

for test in [5456, 120, 121, 23456, 2346, 7654567, 765467]
    println("$test\t", is_esthetic(test) ? "Esthetic" : "Non esthetic")
end
</code></pre>

<p>It may not be obvious, but there is quite a bit of magic going on in this line:</p>

<pre><code>if abs(n[i] - n[i-1]) != 1
</code></pre>

<p><code>n[i]</code> and <code>n[i+1]</code> don&#8217;t contain digits, but characters representing digits (ASCII representation). For example, if we are processing a <code>'1'</code> character, we are processing ASCII char 49. So, perhaps, we should convert them to integers:</p>

<pre><code>if abs(Int(n[i]) - Int(n[i-1])) != 1
</code></pre>

<p>Well, still not quite good. If the number being tested if 12, the line above would compare integers 49 (char <code>’1’</code>) and 50 (char <code>’2’</code>), not numbers 1 and 2. To really compare 1 and 2, we would have to subtract <code>Int['0']</code> (48) from each term:</p>

<pre><code>if abs((Int(n[i]) - Int('0')) - (Int(n[i-1] - Int('0'))) != 1
</code></pre>

<p>Of course, subtracting <code>Int('0')</code> (48) from both terms of a subtraction is useless, as the result will be unchanged. But, more broadly, we don&#8217;t need to go through the trouble of casting the chars to ints, because Julia can easily compute the numerical difference between two characters. It even works with non-numerical characters such as letters:</p>

<pre><code>julia&gt; print('e' - 'c')
2
</code></pre>

<p>Output:</p>

<pre><code>$ julia ./esthetic_nums.jl
5456    Esthetic
120     Non esthetic
121     Esthetic
23456   Esthetic
2346    Non esthetic
7654567 Esthetic
765467  Non esthetic
</code></pre>

<h3>Esthetic Number in Python</h3>

<p>In Python, you can also use subscripts to access individual characters of a string, so I chose to also traverse the string representation of the input integer. But it turned out to be a bit more complicated than in Julia. In Python, we need to cast the individual characters into integers to make the subtraction possible.</p>

<pre><code>def is_esthetic(m):
  n = str(m)
  for i in range(1, len(n)):
    if abs(int(n[i]) - int(n[i - 1 ])) != 1:
      return False
  return True

for test in [5456, 120, 121, 23456, 2346, 7654567, 765467]:
  if is_esthetic(test):
    print("{:&lt;9d} is esthetic".format(test))
  else:
    print("{:&lt;9d} is not esthetic".format(test))
</code></pre>

<p>Output:</p>

<pre><code>$ python3 ./esthetic_nums.py
5456      is esthetic
120       is not esthetic
121       is esthetic
23456     is esthetic
2346      is not esthetic
7654567   is esthetic
765467    is not esthetic
</code></pre>

<h3>Esthetic Number in Ruby</h3>

<p>Like in Python, we need to cast characters to integers to make the subtraction possible in Ruby:</p>

<pre><code>def is_esthetic(m)
    n = m.to_s
    for i in 1..(n.length - 1)
        if (n[i].to_i - n[i-1].to_i).abs != 1
            return false
        end
    end
    return true
end

for test in [ 5456, 120, 121, 23456, 2346, 7654567, 765467]
    printf "%-9d ", test 
    if is_esthetic(test)
        print("is esthetic\n")
    else
        print("is not esthetic\n")
    end
end
</code></pre>

<p>Output:</p>

<pre><code>5456      is esthetic
120       is not esthetic
121       is esthetic
23456     is esthetic
2346      is not esthetic
7654567   is esthetic
765467    is not esthetic
</code></pre>

<h3>Esthetic Number in Ring</h3>

<p>Like in Julia, there is no need to cast characters to integers in Ring:</p>

<pre><code>for test in [5456, 120, 121, 23456, 2346, 7654567, 765467]
    see test
    if is_esthetic(test)
        see " is esthetic" + nl
    else
        see " is not esthetic" + nl
    ok
next

func is_esthetic (num)
    n = "" + num
    for i = 2 to len(n)
        if fabs(n[i] - n[i-1]) != 1
            return false
        ok
    next
    return true
</code></pre>

<p>Output:</p>

<pre><code>$ ring ./esthetic_nums.ring
5456 is esthetic
120 is not esthetic
121 is esthetic
23456 is esthetic
2346 is not esthetic
7654567 is esthetic
765467 is not esthetic
</code></pre>

<h3>Esthetic Number in Kotlin</h3>

<pre><code>import kotlin.math.abs

fun is_esthetic(num: Int): Boolean {
    val n = num.toString()
    for (i in 1..n.length - 1) {
        if (abs(n[i] - n[i-1]) != 1) {
            return false
        }
    }
    return true
}
fun main() {
    for (test in arrayOf(5456, 120, 121, 23456, 2346, 7654567, 765467)) {
        if (is_esthetic(test)) {
            println("$test is esthetic")
        } else {
            println("$test is not esthetic")
        }
    }
}
</code></pre>

<p>Output:</p>

<pre><code>5456 is esthetic
120 is not esthetic
121 is esthetic
23456 is esthetic
2346 is not esthetic
7654567 is esthetic
765467 is not esthetic
</code></pre>

<h3>Esthetic Number in Go</h3>

<pre><code>package main

import (
    "fmt"
    "strconv"
)

func is_esthetic(n int) bool {
    s := strconv.Itoa(n)
    for i := 1; i &lt; len(s); i++ {
        if s[i]-s[i-1] != 1 &amp;&amp; s[i-1]-s[i] != 1 {
            return false
        }
    }
    return true
}
func main() {
    tests := []int{5456, 120, 121, 23456, 2346, 7654567, 765467}
    for _, test := range tests {
        if is_esthetic(test) {
            fmt.Printf("%-9d is esthetic\n", test)
        } else {
            fmt.Printf("%-9d is not esthetic\n", test)
        }
    }
}
</code></pre>

<p>Output:</p>

<pre><code>5456      is esthetic
120       is not esthetic
121       is esthetic
23456     is esthetic
2346      is not esthetic
7654567   is esthetic
765467    is not esthetic
</code></pre>

<h3>Esthetic Number in D</h3>

<pre><code>import std.stdio;
import std.math;
import std.conv;

bool is_esthetic(int num) {
    auto s = to!string(num, 10);
    foreach (i; 1 .. s.length) {
        if (abs(s[i] - s[i-1]) != 1) return false;
    }
    return true;
}
void main() {
    int[] tests = [ 5456, 120, 121, 23456, 2346, 7654567, 765467 ];
    foreach(test; tests) {
        printf("%-9d ", test);
        if (is_esthetic(test)) {
            writeln("is esthetic");
        } else {
            writeln("is not esthetic");
        }
    }
}
</code></pre>

<p>Output:</p>

<pre><code>5456      is esthetic
120       is not esthetic
121       is esthetic
23456     is esthetic
2346      is not esthetic
7654567   is esthetic
765467    is not esthetic
</code></pre>

<h3>Esthetic Number in Nim</h3>

<pre><code>import strutils
import std/strformat

proc is_esthetic(num: int): bool =
  let n = intToStr(num)
  for i in 1..len(n)-1:
    if abs(int(n[i]) - int(n[i-1])) != 1:
      return false
  return true

for test in [5456, 120, 121, 23456, 2346, 7654567, 765467]:
  if is_esthetic(test):
    echo fmt("{test:&lt;9}"), " is esthetic"
  else:
    echo fmt("{test:&lt;9}"), " is not esthetic"
</code></pre>

<p>Output:</p>

<pre><code>5456      is esthetic
120       is not esthetic
121       is esthetic
23456     is esthetic
2346      is not esthetic
7654567   is esthetic
765467    is not esthetic
</code></pre>

<h3>Esthetic Number in Rust</h3>

<p>Sometimes, a strict typing system can be a straight jacket. Rust&#8217;s typing system seems to be such. I was&#8217;t able to find a way to subtract characters and take the absolute value of the result. So I had to use two separate conditions: if <code>n[i] != n[i-1] + 1 &amp;&amp; n[i-1] != n[i] + 1 ...</code></p>

<pre><code>fn is_esthetic(num: i32) -&gt; bool {
    let n = num.to_string();
    for i in 1..n.len() {
        if n.as_bytes()[i] != n.as_bytes()[i-1] + 1 &amp;&amp;
           n.as_bytes()[i-1] != n.as_bytes()[i] + 1 {
            return false
        }
    }
    return true
}

fn main() {
    for test in [5456, 120, 121, 23456, 2346, 7654567, 765467] {
        println!("{} -&gt; {}", test, if is_esthetic (test) { " is esthetic"} else { " is not esthetic"});
    }
}
</code></pre>

<p>Output:</p>

<pre><code>5456 -&gt;  is esthetic
120 -&gt;  is not esthetic
121 -&gt;  is esthetic
23456 -&gt;  is esthetic
2346 -&gt;  is not esthetic
7654567 -&gt;  is esthetic
765467 -&gt;  is not esthetic
</code></pre>

<h3>Esthetic Number in Scala</h3>

<pre><code>object esthetic extends App {
  def is_esthetic(num: Int): Boolean = {
    val digits = num.toString.split("")
    for (i &lt;- 1 to (digits.size) - 1) {
      if ((digits(i).toInt - digits(i-1).toInt).abs != 1) {
        return false
      }
    }
    return true
  }
  val tests = List(5456, 120, 121, 23456, 2346, 7654567, 765467)
  for (test &lt;- tests) {
    if (is_esthetic(test)) {
      println(s"$test is esthetic")
    } else {
      println(s"$test is not esthetic")
    }
  }
}
</code></pre>

<p>Output:</p>

<pre><code>5456 is esthetic
120 is not esthetic
121 is esthetic
23456 is esthetic
2346 is not esthetic
7654567 is esthetic
765467 is not esthetic
</code></pre>

<h3>Esthetic Number in Java</h3>

<p>I&#8217;m not a great fan of Java, because I find it too verbose. But it is good, some times, to take a fresh look at things.</p>

<pre><code>import java.lang.Math;

public class EstheticNumber {
    public static void main(String[] args) {
        Integer[] tests = {5456, 120, 121, 23456, 2346, 7654567, 765467};  
        for (int i = 0; i &lt;= 6; i++) {
            if (is_esthetic(tests[i])) {
                System.out.printf("%-9d is esthetic\n", tests[i]);
            } else {
                System.out.printf("%-9d is not esthetic\n", tests[i]);
            }
        }
    }
    public static boolean is_esthetic(int n) {
        String s = Integer.toString(n);
        for (int i = 1; i &lt; s.length(); i++ ) {
            if (Math.abs((int)(s.charAt(i)) - (int)(s.charAt(i-1))) != 1) {
                return false;
            }
        }
        return true;
    }
}
</code></pre>

<p>Output:</p>

<pre><code>5456      is esthetic
120       is not esthetic
121       is esthetic
23456     is esthetic
2346      is not esthetic
7654567   is esthetic
765467    is not esthetic
</code></pre>

<h2>Task 2: Sylvester&#8217;s Sequence</h2>

<p><em>Write a script to generate first 10 members of Sylvester&#8217;s sequence. For more informations, please refer to the <a href="https://en.wikipedia.org/wiki/Sylvester%27s_sequence">wikipedia page</a>.</em></p>

<p><em>Output:</em></p>

<pre><code>2
3
7
43
1807
3263443
10650056950807
113423713055421844361000443
12864938683278671740537145998360961546653259485195807
165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<p>Each number in the sequence is the product of all previous numbers of the sequence plus 1.</p>

<p>The only potential difficulty with this problem is that we&#8217;re dealing with very large integers so that, for some programming languages at least, we may encounter an integer overflow error (or values may be converted to floats, with a resulting loss of precision).</p>

<h3>Sylvester&#8217;s Sequence in Raku</h3>

<p>In Raku, <code>Int</code> objects store integral numbers of <em>arbitrary</em> size. So we don&#8217;t have to worry about very large integers.</p>

<p>We start with a direct implementation of the definition. We store the sequence in the <code>@s</code> array. To get a new  number, we simply compute the product of all items of the <code>@s</code> array (using the <code>[*]</code> meta-operator) and add it to the array.</p>

<pre><code>my @s = 2;
while @s.elems &lt; 10 {
    push @s, 1 + [*] @s;
}
.say for @s;
</code></pre>

<p>This program displays the following output:</p>

<pre><code>$ raku ./sylvester.raku
2
3
7
43
1807
3263443
10650056950807
113423713055421844361000443
12864938683278671740537145998360961546653259485195807
165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<p>The program runs very fast, but is not as efficient as it could be because we are performing some of the multiplications many times. When computing <code>@s[$n+1]</code>, we know that <code>@s[$n]</code> contains the product of all values between <code>@s[0]</code> and <code>@s[$n-1]</code> plus 1. Therefore, the <code>n + 1</code> item of the sequence can be defined recursively as <code>@s[$n] * (@s[$n] - 1) + 1</code>, so that we can perform only one multiplication each time. This can lead to the following modified implementation:</p>

<pre><code>my @n = 2;
push @n, @n[*-1] * (@n[*-1] - 1) + 1 for 1..^10;
.say for @n;
</code></pre>

<p>This program displays the same output as above:</p>

<pre><code>$ raku ./sylvester2.raku
2
3
7
43
1807
(lines omitted for brevity)
</code></pre>

<h3>Sylvester&#8217;s Sequence in Perl</h3>

<p>In Perl, scalars cannot contain such large integers. But we can use the <code>use BigInt;</code> pragma to convert all numeric literals to <code>Math::BigInt</code>, which can store arbitrarily large integers.</p>

<p>To port the first raku program above to Perl, we implement a <code>prod</code> subroutine that computes the product of all items of its input.</p>

<pre><code>use strict;
use warnings;
use feature "say";
use bigint;

sub prod {
    my $prod = 1;
    $prod *= $_ for @_;
    return $prod;
}

my @s = (2);
while (@s &lt; 10) {
    push @s, 1 + prod @s;
}
say for @s;
</code></pre>

<p>This program displays the following output:</p>

<pre><code>$ perl ./sylvester.pl
2
3
7
43
1807
3263443
10650056950807
113423713055421844361000443
12864938683278671740537145998360961546653259485195807
165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<p>We can avoid the <code>prod</code> subroutine if we use the method of the second Raku program above:</p>

<pre><code>use strict;
use warnings;
use feature "say";
use bigint;

my @s = (2);
push @s, $s[-1] * ($s[-1] - 1) + 1 for 1..9;
say for @s;
</code></pre>

<p>This program displays the same output:</p>

<pre><code>$ perl ./sylvester2.pl
2
3
7
43
1807
(lines omitted for brevity)
</code></pre>

<h3>Sylvester&#8217;s Sequence in bc</h3>

<p>The Unix <code>bc</code> utility is an <em>arbitrary</em> precision calculator language, so it is tempting to use it for a problem in which the only potential difficulty is the use of very large integers. However, <code>bc</code>&#8217;s arrays lack many of the cool features of more modern languages. We will implement the second method above without using any array (printing the values as we compute them).</p>

<pre><code>n = 2
print n, "\n"
count = 1
while (count &lt; 10) {
    n = (n - 1) * n + 1
    print n, "\n"
    count += 1
}
quit
</code></pre>

<p>This script displays the following output:</p>

<pre><code>$ bc ./sylvester.bc
bc 1.06.95
Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation, Inc.
This is free software with ABSOLUTELY NO WARRANTY.
For details type `warranty'.
2
3
7
43
1807
3263443
10650056950807
113423713055421844361000443
12864938683278671740537145998360961546653259485195807
16550664732451996419846819544443918001751315270637749784185138876653\
5868639572406808911988131737645185443
</code></pre>

<p>One last little problem here is that bc cannot print numbers larger than 70 digits on the same line, so that the last Sylvester number above is cut over two lines. We can pipe the bc output through a Perl one-line filter (or some other utility) to reformat properly the faulty line:</p>

<pre><code>$ bc sylvester.bc | perl -pe 's/\\\s//'
2
3
7
43
1807
3263443
10650056950807
113423713055421844361000443
12864938683278671740537145998360961546653259485195807
165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<p>Another way is to set the <code>BC_LINE_LENGTH</code> environment variable to 0:</p>

<pre><code>$ BC_LINE_LENGTH=0 bc sylvester.bc
bc 1.06.95
Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation, Inc.
This is free software with ABSOLUTELY NO WARRANTY.
For details type `warranty'.
2
3
7
43
1807
3263443
10650056950807
113423713055421844361000443
12864938683278671740537145998360961546653259485195807
165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<h3>Sylvester&#8217;s Sequence in dc</h3>

<p>The Unix <code>dc</code> utility is also an <em>arbitrary</em> precision calculator language, so it is tempting to use it for a problem in which the only potential difficulty is the use of very large integers. In fact, bc used to be a standard infix front-end to the dc reverse Polish notation.</p>

<p>This is a dc program to display the first 10 elements of the Sylvester&#8217;s sequence:</p>

<pre><code>2snlnp9sc[1-ln*1+psnlnlc1-sc0lc&gt;m]dsmx
</code></pre>

<p>You can run it as follows:</p>

<pre><code>$ echo '2snlnp9sc[1-ln*1+psnlnlc1-sc0lc&gt;m]dsmx
       ' |  DC_LINE_LENGTH=0 dc
2
3
7
43
1807
3263443
10650056950807
113423713055421844361000443
12864938683278671740537145998360961546653259485195807
165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<p>OK, I must admit that I golfed it. I usually try to use concise syntax, but don&#8217;t commonly golf my solutions. Here, I think that I probably deserve an award for the shortest and most obfuscated golf piece for that problem.</p>

<p>This is now a much more readable version of the same solution:</p>

<pre><code>2sn     # push 2 on the stack, pop 2 off the top of the stack and store it into register n
lnp     # copy the value back on the stack and print it
9sc     # give counter c an initial value of 9
[       # start of macro
  1-    # subtract 1 from stack (value n-1)
  ln    # load n to stack
  *1+p  # compute product n * n-1, add 1 and print
  sn    # pop new value and store it in register n
  ln    # copy new value in  n to stack
  lc    # copy counter to stack
  1-    # decrement counter (subtract 1 from c)
  sc    # store decremented counter in c
  0 lc  # store 0 and counter on stack
  &gt;m    # compare counter to 0 and, if c &gt; 0, run recursively macro in m
]       # end of macro
d       # duplicate macro
sm      # store macro in register m
x       # execute first iteration of macro
</code></pre>

<p>Understanding the solution in details would require a lot more explanations than what I can provide here. You are kindly invited to read <a href="http://blogs.perl.org/users/laurent_r/2022/07/perl-weekly-challenge-173-sylvesters-sequence-in-dc.html">this other blog post</a> where I describe in detail how I solved the problem in dc.</p>

<h3>Sylvester&#8217;s Sequence in Julia</h3>

<p>With regular integers, we obtain totally wrong results, including negative integers and so forth. All we need to do to fix that problem is to declare our initial variable as a <code>BigInt</code>:</p>

<pre><code>s = BigInt(2)
println(s)
for i in 1:9
    s = s * (s - 1) + 1
    println(s)
end
</code></pre>

<p>Output:</p>

<pre><code>$ julia ./sylvester.jl
2
3
7
43
1807
3263443
10650056950807
113423713055421844361000443
12864938683278671740537145998360961546653259485195807
165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<h3>Sylvester&#8217;s Sequence in Python</h3>

<p>Recent versions of Python automatically switch to big integers when needed:</p>

<pre><code>s = [2];
for i in range(9):
  s.append(s[-1] * (s[-1] - 1) + 1)
for j in s:
  print(j)
</code></pre>

<p>Output:</p>

<pre><code>$ python3 sylvester.py
2
3
7
43
1807
3263443
10650056950807
113423713055421844361000443
12864938683278671740537145998360961546653259485195807
165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<h3>Sylvester&#8217;s Sequence in Ruby</h3>

<pre><code># Ruby automatically switches to Bignum when needed
s = 2
print("#{s}\n")
for i in 1..9
    s = s * (s - 1) + 1
    print("#{s}\n")
end
</code></pre>

<p>Output:</p>

<pre><code>2
3
7
43
1807
3263443
10650056950807
113423713055421844361000443
12864938683278671740537145998360961546653259485195807
165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<h3>Sylvester&#8217;s Sequence in Ring</h3>

<p>As far as I can tell, Ring doesn&#8217;t have a BigNum package. But Ring gracefully switches to floating point arithmetics and thus produces fairly decent approximations of the expected result.</p>

<pre><code>s = 2;
see s + nl
for i = 1 to 9
    s = s * (s - 1) + 1
    see s + nl
next
</code></pre>

<p>Output:</p>

<pre><code>$ ring ./sylvester.ring
2
3
7
43
1807
3263443
10650056950807
113423713055421845118910464.00
12864938683278672079501004830742670366487445279604736.00
1.655066473245199625930595525909356695752320791312711997146979916612453687017861571473280717e+104
</code></pre>

<p>The three last Sylvester numbers above are computed with floating point arithmetics. As you can see if you compare with the results obtained with other languages above, only the first 16th to 17th digits are accurate.</p>

<h3>Sylvester Sequence in Scala</h3>

<p>Like in Julia, we only need to declare our initial variable as a <code>BigInt</code> to get the correct results in Scala:</p>

<pre><code>object sylvester extends App {
  var n = BigInt(2)
  println(n)
  for (i &lt;- 1 to 9) {
    n = n * (n - 1) + 1
    println(n)
  }
}
</code></pre>

<p>Output:</p>

<pre><code>2
3
7
43
1807
3263443
10650056950807
113423713055421844361000443
12864938683278671740537145998360961546653259485195807
165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<h3>Sylvester&#8217;s Sequence in Kotlin</h3>

<p>In Kotlin, we import the java <code>java.math.BigInteger</code> library. Note that it doesn&#8217;t know how to mix <code>BigInteger</code> numbers with standard integers in computations, so we need to create <code>one</code>, a <code>BigInteger</code> for 1.</p>

<pre><code>import java.math.BigInteger

fun main () {
    var n = BigInteger("2")
    val one = BigInteger("1")
    for (i in 1..9) {
        n = n * (n - one) + one
        println(n)
    }
}
</code></pre>

<p>Output:</p>

<pre><code>3
7
43
1807
3263443
10650056950807
113423713055421844361000443
12864938683278671740537145998360961546653259485195807
165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<h3>Sylvester&#8217;s Sequence in D</h3>

<pre><code>import std.stdio;
import std.bigint;

void main() {
    BigInt s = "2";
    writeln(s);
    for (int i = 1; i &lt;= 9; i++) {
        s = s * (s - 1) + 1;
        writeln(s);
    }
}
</code></pre>

<p>Output:</p>

<pre><code>2
3
7
43
1807
3263443
10650056950807
113423713055421844361000443
12864938683278671740537145998360961546653259485195807
165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<h3>Sylvester&#8217;s Sequence in Lua</h3>

<p>I did not succeed to use the library for large integers. Perhaps my Lua installation is faulty, or I missed something else. I still want to show the result to illustrate how wrong a program can go in the event of an integer overflow not properly managed. We&#8217;ve seen before that Ring (for example) automatically switches to floats and provides results accurate to the first 16 decimal places. In Lua, this goes horribly wrong, and displays even negative integers.</p>

<pre><code>-- Does not work properly
s = 2
print(s)
for i = 1, 9 do
    s = s * (s - 1) + 1
    print(s)
end
</code></pre>

<p>Output:</p>

<pre><code>2
3
7
43
1807
3263443
10650056950807
-3591524960174918149
-8362769992138052065
4108952388197251491
</code></pre>

<h3>Sylvester&#8217;s Sequence in Go</h3>

<p>This works properly, but the method-invocation syntax for using big integers in Go is just plainly horrible and very difficult to use. I expected better from one of the world&#8217;s largest and wealthiest corporations and some legendary computer scientists, especially when it is claimed that Go was designed to be simple. OK, I must admit that it is still simpler than dc (see above), but dc was designed and written almost half a century ago.</p>

<pre><code>// Go big int syntax really sucks
package main

import (
    "fmt"
    "math/big"
)

func main() {
    s := big.NewInt(2)
    fmt.Println(0, ": ", s)
    one := big.NewInt(1)
    for i := 1; i &lt;= 9; i++ {
        s.Add(new(big.Int).Mul(s, s), new(big.Int).Sub(one, s))
        fmt.Println(i, ": ", s)
    }
}
</code></pre>

<p>Output:</p>

<pre><code>0 :  2
1 :  3
2 :  7
3 :  43
4 :  1807
5 :  3263443
6 :  10650056950807
7 :  113423713055421844361000443
8 :  12864938683278671740537145998360961546653259485195807
9 :  165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<h3>Sylvester&#8217;s Sequence in Nim</h3>

<pre><code>import bigints

var s = 2.initBigInt
echo s
for i in 1..9:
    s = s * (s - 1) + 1
    echo s
</code></pre>

<p>Output:</p>

<pre><code>2
3
7
43
1807
3263443
10650056950807
113423713055421844361000443
12864938683278671740537145998360961546653259485195807
165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<h3>Sylvester&#8217;s Sequence in Dart</h3>

<p>Like in Kotlin, <code>BigInt</code> objects don&#8217;t mix in properly with regular integers in Dart. So we need to declare a <code>one</code> BigInt object for integer 1.</p>

<p>void main() {
    var s = BigInt.from(2);
    print(s);
    var one = BigInt.from(1);
    for (int i = 1; i &lt;= 9; i++) {
        s = s * (s - one) + one;
        print(s);
    }
}</p>

<p>Output:</p>

<pre><code>2
3
7
43
1807
3263443
10650056950807
113423713055421844361000443
12864938683278671740537145998360961546653259485195807
165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<h3>Sylvester&#8217;s Sequence in JavaScript</h3>

<p>Here, again, we need to declare a <code>one</code> <code>BigInt</code> object for integer 1.</p>

<pre><code>let s = BigInt (2)
let one = BigInt (1)
console.log(s + " ");
for (let i = 1; i &lt;= 9; i++) {
    s = s * (s - one) + one
    console.log(s + " ");
}
</code></pre>

<p>Output:</p>

<pre><code>2 
3 
7 
43 
1807 
3263443 
10650056950807 
113423713055421844361000443 
12864938683278671740537145998360961546653259485195807 
165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<h3>Sylvester&#8217;s Sequence in TCL</h3>

<p>TCL natively supports arbitrarily large integers.</p>

<pre><code>set s 2
puts $s
for {set i 1} {$i &lt;= 9} {incr i} {
    set s [expr ($s * ($s - 1) + 1)]
    puts $s
}
</code></pre>

<p>Output:</p>

<pre><code>2
3
7
43
1807
3263443
10650056950807
113423713055421844361000443
12864938683278671740537145998360961546653259485195807
165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<h3>Sylvester&#8217;s Sequence in Java</h3>

<p>I said before that I found Java to be a bit too verbose. If you don&#8217;t know what I mean, just compare the Java solution below with the TCL solution above.</p>

<pre><code>import java.math.BigInteger;

public class Sylvester {
    public static void main(String[] args) {
        BigInteger n = BigInteger.valueOf(2);
        System.out.printf("%s\n", n);
        BigInteger one = BigInteger.valueOf(1);
        for (int i = 1; i &lt;= 9; i++) {
            n = (n.multiply(n.subtract(one))).add(one);
            System.out.printf("%s\n", n);
        }
    }
}
</code></pre>

<p>Output:</p>

<pre><code>2
3
7
43
1807
3263443
10650056950807
113423713055421844361000443
12864938683278671740537145998360961546653259485195807
165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<h2>Wrapping up</h2>

<p>The next week Perl Weekly Challenge will start soon. If you want to participate in this challenge, please check https://perlweeklychallenge.org/ and make sure you answer the challenge before 23:59 BST (British summer time) on July 24, 2022. And, please, also spread the word about the Perl Weekly Challenge if you can.</p>

        

           </div><!-- card-text -->     </div>
            <div class="card-footer">
            </div><!-- card-footer -->
          </div><!-- card -->
          <div class="card" id="card_4">
            <div class="card-header">
              <h2 class="card-title"><a href="http://blogs.perl.org/users/dean/2022/07/ideas-from-tprc2022-tools-to-help-refactor-large-mature-code-bases.html">Ideas from TPRC2022: Tools to help refactor large mature code bases</a></h2>
<a href="http://blogs.perl.org/" class="badge badge-primary" style="float: left">blogs.perl.org</a>

              <p class="text-right"><small>Published by Dean
 on Sunday 17 July 2022 00:22</small></p>
            </div> <!-- card-header -->
     <div class="card-body">       <div class="card-text">
        <p>Every Perl gig I have ever had, and from most of the conversations I had at this years Perl and Raku Conference, was working on a large code based that is serving the business and it's customers very well such that the business is profitable (i.e. a mature code base). </p>

<p>This is an enviable position to be in but whilst this software is robust from the outside, there is often a reluctance to make dramatic changes. Unfortunately code that is perceived as too  fragile to touch tends to be replaced and replaced in another language. </p>

<p>The <a href="https://metacpan.org/pod/PPI">PPI</a> + <a href="https://metacpan.org/pod/Class::Inspector">Class::Inspector</a> combination is already being used by people I've spoken too, in bespoke tools to refactor large code bases reliably.</p>

<p>We have frameworks for testing (Test:: etc) and linting (Perl::Critic) with suites of well established reusable polices, so why not a similar framework for refactoring?</p>

<p>Such a tool might have provided polices to assist replacing deprecated syntax, migrate between "Try" implementations, fixing up scalar vs list context, just to name a few.</p>

<p>Achieving a 100% successful transition on any given code base is probably unrealistic, being able to produce diffs that can be accepted by human review 80%+ of the time would present excellent value. </p>

<p>I see this as being very similar to unit testing - consider that whilst some functionality in a codebase may be extraordinarily challenging to write tests for, this shouldn't be an excuse to write no tests at all. Achieving an 80% test coverage might be considered outstanding and provide enormous value. </p>

<p>Perhaps folks already have something they can publish to CPAN or just throw up on Github to socialize ideas? What's your thoughts?</p>
        
           </div><!-- card-text -->     </div>
            <div class="card-footer">
            </div><!-- card-footer -->
          </div><!-- card -->
          <div class="card" id="card_5">
            <div class="card-header">
              <h2 class="card-title"><a href="http://blogs.perl.org/users/alceu_rodrigues_de_freitas_junior/2022/07/the-cpan-testers-game.html">The CPAN Testers game</a></h2>
<a href="http://blogs.perl.org/" class="badge badge-primary" style="float: left">blogs.perl.org</a>

              <p class="text-right"><small>Published by Alceu Rodrigues de Freitas Junior
 on Thursday 14 July 2022 01:13</small></p>
            </div> <!-- card-header -->
     <div class="card-body">       <div class="card-text">
        <p>I'm not sure of how many of you know the ecosystem of Perl QA, so I decided to move an old article of mine to medium.com and update it to reflect all the changes that happened between those years.</p>

<p>Here is <a href="https://medium.com/@alceu.freitas.jr/the-cpan-testers-game-e09a260c6008">the link to the old-new article</a>.</p>

<p>I also made several changes to the project <a href="https://github.com/glasswalk3r/cpan-openbsd-smoker">cpan-openbsd-smoker</a> and would like to share with the community the details about it, specially with the people that not only publishes modules to CPAN, but also those are part (or want to be part of) the QA group.</p>

<p><big>The CPAN OpenBSD Smoker project</big></p>

<p>This project basically applies a lot of documented steps scattered around and produces an local VM running OpenBSD with a running CPAN Smoker in an automated fashion.</p>

<p>In the first versions, much of the automation was implemented with Bash scripts. Later, I started introducing Perl code to replace the scripts that become more complex. Then I added <a href="http://savannah.gnu.org/projects/parallel">parallel</a> to the mix and things started getting really complicated.</p>

<p>Not surprisingly, I replaced almost everything with Ansible and although some features were discarded during the process, the project now is much easier to understand and maintain.</p>

<p>Currently I'm considering writing a more generic Ansible role to allow the setup of a CPAN Smoker in not only OpenBSD, but all OSes that supports Perl and Ansible itself.</p>

<p><big>Why Ansible?</big></p>

<p>Since the beginning of the project I was using Vagrant. Adding Packer to the mix followed quickly because it helped putting a lot of effort in creating a base Vagrant box, which speed up the provisioning process greatly.</p>

<p>Adding Ansible to the mix with Vagrant and Packer was really easy.</p>

<p>First because I already knew Ansible. Second, because it was nicely integrated with both tools. Third, many of what I was implementing with my own code already exists ready to use as Ansible modules and roles.</p>

<p>I already asked myself if I shouldn't try to use <a href="https://www.rexify.org/">Rex</a> instead, since is written in Perl and all this work is to help the Perl ecosystem.</p>

<p>As I stated before, I already know Ansible. While I think Rex might do the same things, I'm not sure about. And since I need to have it integrated with Packer and Vagrant (the first is written in Golang, the second in Ruby) I believe it will take a long walk before I could make it happen.</p>

<p>If I'm wrong, please let me know. Or even better, send me a pull request!</p>

<p><big>What about preferences?</big></p>

<p>Another aspect of the project that I would like share is that it uses distroprefs to block Perl distribution to run in the smoker. Yes, you read it right.</p>

<p>Some distributions just bring the smoker down for different reasons. What makes me worried is that those distribution maintainers might not even know that those things happens.</p>

<p>The first problem is to communicate those issues. One thing that occurred me is that I could open a bug for the distribution, but that's a lot of work to do it manually by myself. The idea of distributions not being actively maintained surely also don't help.</p>

<p>What I did is to make those distroprefs <a href="https://github.com/glasswalk3r/cpan-openbsd-smoker/tree/master/prefs">available through the Github project</a>.</p>

<p>A nice this is that the distroprefs YAML format allows a comment to explain what is happening over there. I wish we could <a href="https://markmail.org/search/list:org.perl.cpan-testers-discuss#query:list%3Aorg.perl.cpan-testers-discuss%20from%3A%22Alceu%20Rodrigues%20de%20Freitas%20Junior%20via%20cpan-testers-discuss%22+page:2+mid:s73ttqc6tia6ed7t+state:results">selective choose which distribution not to install after testing</a>, but I guess is not possible right now.</p>

<p>In order to make it easier to maintain these files, I developed the CLI dblock (available in the CPAN-Reporter-Smoker-OpenBSD distribution, which I'm planning to migrate to it's own Git repository).</p>

<p>If there is a better way to manage those preferences and communicate with the distribution maintainers, please let me know.</p>

<p>Finally, if you want to release your distribution from the blockage, please let me know.</p>
        
           </div><!-- card-text -->     </div>
            <div class="card-footer">
            </div><!-- card-footer -->
          </div><!-- card -->
          <div class="card" id="card_6">
            <div class="card-header">
              <h2 class="card-title"><a href="http://blogs.perl.org/users/tom_wyant/2022/07/scalar-context-lists-versus-arrays.html">Scalar Context: Lists Versus Arrays</a></h2>
<a href="http://blogs.perl.org/" class="badge badge-primary" style="float: left">blogs.perl.org</a>

              <p class="text-right"><small>Published by Tom Wyant
 on Tuesday 12 July 2022 23:54</small></p>
            </div> <!-- card-header -->
     <div class="card-body">       <div class="card-text">
        <p>For a long time after I first encountered Perl, I looked on "list" and "array" as essentially interchangeable concepts. A list was simply the source construct corresponding to an array. This idea is <strong>mostly</strong> correct. But as they say, the devil is in the details.</p>

<p>One of the differences is what happens to them in scalar context. An array evaluates to the number of elements it contains. A list evaluates to its last element. So:</p>

<pre>
my @array = qw{ one two five };
say scalar @array;  # prints '3'
{
    no warnings 'void'; # Note the need for this
    say scalar( qw{ one two five } ); # prints 'five'
}
</pre>

<p>Okay, that is a trivial example. It becomes more interesting when you consider that subroutines inherit their calling context. If called in scalar context, a subroutine that returns a list behaves differently than one that returns an array:</p>

<pre>
sub array {
    state $array = [ qw{ one two five } ];
    return @{ $array };
}
sub list {
    return qw{ one two five };
}
say scalar array(); # prints 3
say scalar list();  # prints 'five';
</pre>

<p>Now, there is some sentiment against subroutines that "behave differently" in scalar and list context. Usually this is thought of in terms of the <a href="https://perldoc.perl.org/functions/wantarray"><code>wantarray()</code></a> built-in, and there is actually Perl Critic policy <a href="https://metacpan.org/pod/Perl::Critic::Policy::Community::Wantarray"><code>Perl::Critic::Community::WantArray</code></a> to flag these.</p>

<p>But it seems to me that any Perl subroutine that returns more than one value <strong>will</strong> behave differently in scalar context: it's just a question of whether you want the array behavior, the list behavior, or the arbitrary behavior you can get with <code>wantarray()</code>. The difference between good code and bad code is a matter of choosing this behavior carefully.</p>

<p>P.S.</p>

<p>What do you do if you have an array but want list behavior? There is no <code>list</code> built-in corresponding to the <code>scalar</code> built-in. The <a href="https://perldoc.perl.org/functions/scalar">documentation for <code>scalar</code></a> talks about this, but only addresses interpolation. In the general case, though, what seems to work is slicing the entire array:</p>

<pre>
say scalar @array[ 0 .. $#array ]; # prints 'five'
</pre>

<p>Or, if you want to encapsulate this behavior,</p>

<pre>
sub make_list { return @_[0..$#_] }
say scalar make_list( qw{ one two five } ); # prints 'five';
</pre>

<p>No, I did not come up with this on my own. I got it from <a href="https://stackoverflow.com/questions/34685788/convert-array-to-list">Stack Overflow</a>, specifically from <code>user2404501</code>'s response.</p>

<p>Be careful of getting too fancy with this. <code>scalar @array[ 0 .. $#array ]</code> is written <strong>much</strong> more clearly as <code>$array[-1]</code>.</p>

        
           </div><!-- card-text -->     </div>
            <div class="card-footer">
            </div><!-- card-footer -->
          </div><!-- card -->
          <div class="card" id="card_7">
            <div class="card-header">
              <h2 class="card-title"><a href="http://www.rabbitfarm.com/cgi-bin/blosxom/2022/07/10#pwc172">Partition the Summary</a></h2>
<a href="http://www.rabbitfarm.com/cgi-bin/blosxom/perl" class="badge badge-primary" style="float: left">RabbitFarm Perl</a>

              <p class="text-right"><small>Published
 on Sunday 10 July 2022 20:39</small></p>
            </div> <!-- card-header -->
     <div class="card-body">       <div class="card-text">
<p><em>The examples used here are from the weekly challenge problem statement and demonstrate 
the working solution.</em></p>

<h2>Part 1</h2>

<p><em>You are given two positive integers, $n and $k. Write a script to find out the Prime 
Partition of the given number. No duplicates are allowed.</em></p>

<h3>Solution</h3>

<pre><code class="perl">
use strict;
use warnings;
use boolean;
use Math::Combinatorics;

sub sieve_atkin{
    my($upper_bound) = @_;
    my @primes = (2, 3, 5);
    my @atkin = (false) x $upper_bound;    
    my @sieve = (1, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 49, 53, 59);
    for my $x (1 .. sqrt($upper_bound)){
        for(my $y = 1; $y <= sqrt($upper_bound); $y+=2){
            my $m = (4 * $x ** 2) + ($y ** 2);
            my @remainders;  
            @remainders = grep {$m % 60 == $_} (1, 13, 17, 29, 37, 41, 49, 53) if $m <= $upper_bound; 
            $atkin[$m] = !$atkin[$m] if @remainders; 
        }          
    } 
    for(my $x = 1; $x <= sqrt($upper_bound); $x += 2){
        for(my $y = 2; $y <= sqrt($upper_bound); $y += 2){
            my $m = (3 * $x ** 2) + ($y ** 2);
            my @remainders;  
            @remainders = grep {$m % 60 == $_} (7, 19, 31, 43) if $m <= $upper_bound; 
            $atkin[$m] = !$atkin[$m] if @remainders; 
        }          
    }   
    for(my $x = 2; $x <= sqrt($upper_bound); $x++){
        for(my $y = $x - 1; $y >= 1; $y -= 2){
            my $m = (3 * $x ** 2) - ($y ** 2);
            my @remainders;  
            @remainders = grep {$m % 60 == $_} (11, 23, 47, 59) if $m <= $upper_bound; 
            $atkin[$m] = !$atkin[$m] if @remainders; 
        }          
    } 
    my @m;
    for my $w (0 .. ($upper_bound / 60)){
        for my $s (@sieve){
            push @m, 60 * $w + $s;  
        }
    }
    for my $m (@m){
        last if $upper_bound < ($m ** 2);
        my $mm = $m ** 2;
        if($atkin[$m]){
            for my $m2 (@m){
                my $c = $mm * $m2;
                last if $c > $upper_bound;
                $atkin[$c] = false;
            }
        }
    }
    map{ push @primes, $_ if $atkin[$_] } 0 .. @atkin - 1;
    return @primes; 
}

sub prime_partition{
    my($n, $k) = @_;
    my @partitions;
    my @primes = sieve_atkin($n);
    my $combinations = Math::Combinatorics->new(count => $k, data => [@primes]);
    while(my @combination = $combinations->next_combination()){
        push @partitions, [@combination] if unpack("%32I*", pack("I*", @combination)) == $n;
    }
    return @partitions;
}

MAIN:{
    my($n, $k);
    $n = 18, $k = 2;
    map{ 
        print "$n = " . join(", ", @{$_}) . "\n"
    } prime_partition($n, $k);
    print"\n\n";
    $n = 19, $k = 3;
    map{ 
        print "$n = " . join(", ", @{$_}) . "\n"
    } prime_partition($n, $k);
}
</code></pre>

<h3>Sample Run</h3>

<pre><code class="shell">
$ perl perl/ch-1.pl
18 = 7, 11
18 = 5, 13


19 = 3, 11, 5
</code></pre>

<h3>Notes</h3>

<p>Only when writing this short blog did I realize there is a far more efficient way of 
doing this!</p>

<p>Here we see a brute force exhaustion of all possible combinations. This works alright for 
when <code>$n</code> and <code>$k</code> are relatively small. For larger values a procedure like this would be
better,</p>

<pre>
1. Obtain all primes $p < $n
2. Start with $n and compute $m = $n - $p for all $p
3. If $m is prime and $k = 2 DONE
4. Else set $n = $m and repeat, computing a new $m with all $p < $m stopping with the same criteria if $m is prime and $k is satisfied
</pre>

<p>This procedure would be a natural fit for recursion, if you were in the mood for that sort 
of thing.</p>

<h2>Part 2</h2>

<p><em>You are given an array of integers. Write a script to compute the five-number summary of 
the given set of integers.</em></p>

<h3>Solution</h3>

<pre><code class="perl">
use strict;
use warnings;
sub five_number_summary{
    my @numbers = @_;
    my($minimum, $maximum, $first_quartile, $median, $third_quartile);
    my @sorted = sort {$a <=> $b} @numbers;
    $minimum = $sorted[0];
    $maximum = $sorted[@sorted - 1];
    if(@sorted % 2 == 0){
        my $median_0 = $sorted[int(@sorted / 2) - 1];
        my $median_1 = $sorted[int(@sorted / 2)];
        $median = ($median_0 + $median_1) / 2;
        my @lower_half = @sorted[0 .. int(@sorted / 2)];
        my $median_lower_0 = $lower_half[int(@lower_half / 2) - 1];
        my $median_lower_1 = $lower_half[int(@lower_half / 2)];
        $first_quartile = ($median_lower_0 + $median_lower_1) / 2;       
        my @upper_half = @sorted[int(@sorted / 2) .. @sorted];
        my $median_upper_0 = $upper_half[int(@upper_half / 2) - 1];
        my $median_upper_1 = $upper_half[int(@upper_half / 2)];
        $third_quartile = ($median_upper_0 + $median_upper_1) / 2;
    }
    else{
        $median = $sorted[int(@sorted / 2)];
        $first_quartile = [@sorted[0 .. int(@sorted / 2)]]->[int(@sorted / 2) / 2];
        $third_quartile = [@sorted[int(@sorted / 2) .. @sorted]]->[(@sorted - int(@sorted / 2)) / 2];
    }
    return {
        minimum => $minimum, 
        maximum => $maximum, 
        first_quartile => $first_quartile, 
        median => $median, 
        third_quartile => $third_quartile
    };
}

MAIN:{
    my @numbers;
    my $five_number_summary;
    @numbers = (6, 3, 7, 8, 1, 3, 9);
    print join(", ", @numbers) . "\n";
    $five_number_summary = five_number_summary(@numbers);
    map{
        print "$_: $five_number_summary->{$_}\n";
    } keys %{$five_number_summary};
    print "\n\n";
    @numbers = (2, 6, 3, 8, 1, 5, 9, 4);
    print join(", ", @numbers) . "\n";    
    $five_number_summary = five_number_summary(@numbers);
    map{
        print "$_: $five_number_summary->{$_}\n";
    } keys %{$five_number_summary};
    print "\n\n";
    @numbers = (1, 2, 2, 3, 4, 6, 6, 7, 7, 7, 8, 11, 12, 15, 15, 15, 17, 17, 18, 20);
    print join(", ", @numbers) . "\n";      
    $five_number_summary = five_number_summary(@numbers);
    map{
        print "$_: $five_number_summary->{$_}\n";
    } keys %{$five_number_summary};
}
</code></pre>

<h3>Sample Run</h3>

<pre><code class="shell">
$ perl perl/ch-2.pl
6, 3, 7, 8, 1, 3, 9
third_quartile: 8
maximum: 9
minimum: 1
first_quartile: 3
median: 6


2, 6, 3, 8, 1, 5, 9, 4
median: 4.5
first_quartile: 2.5
minimum: 1
maximum: 9
third_quartile: 7


1, 2, 2, 3, 4, 6, 6, 7, 7, 7, 8, 11, 12, 15, 15, 15, 17, 17, 18, 20
maximum: 20
third_quartile: 15
first_quartile: 5
median: 7.5
minimum: 1
</code></pre>

<h3>Notes</h3>

<p>Note that the case of an even or odd number of elements of the list (and sublists) 
requires slightly special handling.</p>

<h2>References</h2>

<p><a href="https://theweeklychallenge.org/blog/perl-weekly-challenge-172/">Challenge 172</a></p>       </div><!-- card-text -->     </div>
            <div class="card-footer">
            </div><!-- card-footer -->
          </div><!-- card -->
          <div class="card" id="card_8">
            <div class="card-header">
              <h2 class="card-title"><a href="http://www.rabbitfarm.com/cgi-bin/blosxom/2022/07/03#pwc171">Abundant Composition</a></h2>
<a href="http://www.rabbitfarm.com/cgi-bin/blosxom/perl" class="badge badge-primary" style="float: left">RabbitFarm Perl</a>

              <p class="text-right"><small>Published
 on Sunday 03 July 2022 12:39</small></p>
            </div> <!-- card-header -->
     <div class="card-body">       <div class="card-text">
<p><em>The examples used here are from the weekly challenge problem statement and demonstrate 
the working solution.</em></p>

<h2>Part 1</h2>

<p><em>Write a script to generate the first twenty Abundant Odd Numbers.</em></p>

<h3>Solution</h3>

<pre><code class="perl">
use strict;
use warnings;
sub proper_divisors{
    my($n) = @_;
    my @divisors;
    for my $x (1 .. $n / 2){
        push @divisors, $x if $n % $x == 0;
    }
    return @divisors;
}

sub n_abundant_odd{
    my($n) = @_; 
    my $x = 0;
    my @odd_abundants;
    {
        push @odd_abundants, $x if $x % 2 == 1 && unpack("%32I*", pack("I*", proper_divisors($x))) > $x;
        $x++;
        redo if @odd_abundants < $n;
    }
    return @odd_abundants;
}

MAIN:{
    print join(", ", n_abundant_odd(20)) . "\n";
}
</code></pre>

<h3>Sample Run</h3>

<pre><code class="shell">
$ perl perl/ch-1.pl
945, 1575, 2205, 2835, 3465, 4095, 4725, 5355, 5775, 5985, 6435, 6615, 6825, 7245, 7425, 7875, 8085, 8415, 8505, 8925
</code></pre>

<h3>Notes</h3>

<p>The solution here incorporated a lot of elements from previous weekly challenges. That is 
to say it is quite familiar, I continue to be a fan of <code>redo</code> as well as the <code>pack/unpack</code>
method of summing the elements of an array.</p>

<h2>Part 2</h2>

<p><em>Create sub compose($f, $g) which takes in two parameters $f and $g as subroutine refs 
and returns subroutine ref i.e. compose($f, $g)->($x) = $f->($g->($x)).</em></p>

<h3>Solution</h3>

<pre><code class="perl">
use strict;
use warnings;
sub f{
    my($x) = @_;
    return $x + $x;
}

sub g{
    my($x) = @_;
    return $x * $x;
}

sub compose{
    my($f, $g) = @_;
    return sub{
        my($x) = @_;
        return $f->($g->($x));
    };
}

MAIN:{
    my $h = compose(\&f, \&g);
    print $h->(7) . "\n";
}
</code></pre>

<h3>Sample Run</h3>

<pre><code class="shell">
$ perl perl/ch-2.pl
98
</code></pre>

<h3>Notes</h3>

<p>This problem incorporates some interesting concepts, especially from functional 
programming. Treating functions in a <em>first class way</em>, that is, passing them as 
parameters, manipulating them, dynamically generating new ones are commonly performed in
functional programming languages such as Lisp and ML. Here we can see that Perl can quite
easily do these things as well!</p>

<h2>References</h2>

<p><a href="https://theweeklychallenge.org/blog/perl-weekly-challenge-171/">Challenge 171</a></p>       </div><!-- card-text -->     </div>
            <div class="card-footer">
            </div><!-- card-footer -->
          </div><!-- card -->
          <div class="card" id="card_9">
            <div class="card-header">
              <h2 class="card-title"><a href="http://www.rabbitfarm.com/cgi-bin/blosxom/2022/06/19#pwc169">Brilliantly Discover Achilles' Imperfection</a></h2>
<a href="http://www.rabbitfarm.com/cgi-bin/blosxom/perl" class="badge badge-primary" style="float: left">RabbitFarm Perl</a>

              <p class="text-right"><small>Published
 on Sunday 19 June 2022 12:39</small></p>
            </div> <!-- card-header -->
     <div class="card-body">       <div class="card-text">
<p><em>The examples used here are from the weekly challenge problem statement and demonstrate 
the working solution.</em></p>

<h2>Part 1</h2>

<p><em>Write a script to generate the first 20 Brilliant Numbers.</em></p>

<h3>Solution</h3>

<pre><code class="perl">
use strict;
use warnings;
sub prime_factor{
    my $x = shift(@_); 
    my @factors;    
    for(my $y = 2; $y <= $x; $y++){
        next if $x % $y;
        $x /= $y;
        push @factors, $y;
        redo;
    }
    return @factors;  
}

sub is_brilliant{
    my($n) = @_;
    my @factors = prime_factor($n); 
    return @factors == 2 && length($factors[0]) == length($factors[1]);
}

sub n_brilliants{
    my($n) = @_;
    my @brilliants;
    my $i = 0;
    {
       push @brilliants, $i if is_brilliant($i);
       $i++;
       redo if @brilliants < $n;
    }
    return @brilliants;
}

MAIN:{
    print join(", ", n_brilliants(20)) . "\n";
}
</code></pre>

<h3>Sample Run</h3>

<pre><code class="shell">
$ perl perl/ch-1.pl
4, 6, 9, 10, 14, 15, 21, 25, 35, 49, 121, 143, 169, 187, 209, 221, 247, 253, 289, 299
</code></pre>

<h3>Notes</h3>

<p>The solution here incorporated a lot of elements from previous weekly challenges. That is 
to say it is quite familiar, I continue to be a fan of <code>redo</code>!</p>

<h2>Part 2</h2>

<p><em>Write a script to generate the first 20 Achilles Numbers.</em></p>

<h3>Solution</h3>

<pre><code class="perl">
use strict;
use warnings;
use POSIX;
use boolean;

sub prime_factor{
    my $x = shift(@_); 
    my @factors;    
    for (my $y = 2; $y <= $x; $y++){
        next if $x % $y;
        $x /= $y;
        push @factors, $y;
        redo;
    }
    return @factors;  
}

sub is_achilles{
    my($n) = @_;
    my @factors = prime_factor($n); 
    for my $factor (@factors){
        return false if $n % ($factor * $factor) != 0;
    }
    for(my $i = 2; $i <= sqrt($n); $i++) {
        my $d = log($n) / log($i) . "";
        return false if ceil($d) == floor($d);  
    }
    return true;
}

sub n_achilles{
    my($n) = @_;
    my @achilles;
    my $i = 1;
    {
       $i++;
       push @achilles, $i if is_achilles($i);
       redo if @achilles < $n;
    }
    return @achilles;
}

MAIN:{
    print join(", ", n_achilles(20)) . "\n";
}
</code></pre>

<h3>Sample Run</h3>

<pre><code class="shell">
$ perl perl/ch-2.pl
72, 108, 200, 288, 392, 432, 500, 648, 675, 800, 864, 968, 972, 1125, 1152, 1323, 1352, 1372, 1568, 1800
</code></pre>

<h3>Notes</h3>

<p>This problem revealed something interesting with how, apparently, certain functions will
handle integer and floating point values. The issue arises when we are computing 
logarithms. We can see the issue in isolation in a one liner.</p>

<p><code>perl -MPOSIX -e '$d = log(9) / log(3); print ceil($d) . "\t" . floor($d) . "\t$d\n"'</code></p>

<p>which prints <code>3       2       2</code>. Notice that <code>log(9) / log(3)</code> is exactly <code>2</code> but, ok, 
floating point issues maybe it is 2.0000000001 and <code>ceil</code> will give 3. 
But why does this work?</p>

<p><code>perl -MPOSIX -e '$d = sqrt(9); print ceil($d) . "\t" . floor($d) . "\t$d\n"'</code></p>

<p>which gives <code>3       3       3</code>. I am not sure what sqrt is doing differently? I guess 
how it stores the result internally? By the way, I am doing this to check is the result is 
an integer. That is if ceil($x) == floor($x), but that isn't working here as expected but 
I have used that trick in the past. I guess only with sqrt in the past though so never 
encountered this.</p>

<p>The trick to work around this, in the solution to the challenge is like this:</p>

<p><code>perl -MPOSIX -e '$d = log(9) / log(3)  . ""; print ceil($d) . "\t" . floor($d) . "\t$d\n"'</code></p>

<p>this does what I want and gives <code>2       2       2</code>. I guess that drops the 
infinitesimally small decimal part when concatenating and converting to a string which 
stays gone when used numerically? </p>

<p>Of course, there are other ways to do this. For example <code>abs($x - int(x)) &lt; 1e-7</code> will 
ensure that, within a minuscule rounding error, <code>$x</code> is an integer.</p>

<h2>References</h2>

<p><a href="https://theweeklychallenge.org/blog/perl-weekly-challenge-169/">Challenge 169</a></p>       </div><!-- card-text -->     </div>
            <div class="card-footer">
            </div><!-- card-footer -->
          </div><!-- card -->

        </div><!-- col-md-8 -->
        <div class="col-md-2">
<script type="text/javascript"><!--
google_ad_client = "pub-3663319204757145";
/* planet */
google_ad_slot = "8413744374";
google_ad_width = 120;
google_ad_height = 600;
//-->
</script>
<script type="text/javascript"
src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
        </div><!-- col-md-2 -->
      </div><!-- row -->
      <footer class="footer">
        <div class="container-fluid">
          <div class="row>
            <div class="col-md-8">
              <address><a href="https://twitter.com/@davorg">@davorg</a> / Monday 18 July 2022 12:59 UTC</address>
            </div>
          </div>
        </div><!-- container -->
      </footer>
    </div><!-- container -->
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-56332-76"></script>
    <script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-56332-76');
    </script>
    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <script>window.jQuery || document.write('<script src="../../assets/js/vendor/jquery.min.js"><\/script>')</script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"
            integrity="sha384-B4gt1jrGC7Jh4AgTPSdUtOBvfO8shuf57BaghqFfPlYxofvL8/KUEfYiJOMMV+rV"
            crossorigin="anonymous"></script>
    <script src="/script.js"></script>
  </body>
</html>
