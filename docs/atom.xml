<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Planet Perl</title>
  <link rel="alternate" href="https://perl.theplanetarium.org/" type="text/html"/>
  <subtitle>There's More Than One Way To Aggregate It</subtitle>
  <author>
    <name>Dave Cross</name>
    <email></email>
  </author>
  <updated>2022-07-17T01:00:58Z</updated>
  <link rel="self" href="https://perl.theplanetarium.org/" type="application/atom+xml"/>
  <id>https://perl.theplanetarium.org/</id>
  <entry>
    <title>Perl Weekly Challenge 173: Sylvester's Sequence in dc</title>
    <link rel="alternate" href="http://blogs.perl.org/users/laurent_r/2022/07/perl-weekly-challenge-173-sylvesters-sequence-in-dc.html"/>
    <id>tag:blogs.perl.org,2022:/users/laurent_r//3226.10850</id>
    <published>2022-07-16T00:25:26Z</published>
    <updated>2022-07-17T00:08:47Z</updated>
    <author>
        <name>laurent_r</name>
        <uri>https://laurent-rosenfeld.developpez.com/</uri>
    </author>
    <content type="html" xml:lang="en" xml:base="http://blogs.perl.org/users/laurent_r/">
        <![CDATA[<p>This blog is an answer to the second task of the Week 173 of the <a href="https://perlweeklychallenge.org/blog/perl-weekly-challenge-173/">Perl Weekly Challenge</a> organized by <a href="http://blogs.perl.org/users/mohammad_s_anwar/">Mohammad S. Anwar</a>.</p>

<p>Originally, the Perl Weekly Challenge called for solutions in Perl and Raku (also known as Perl 6 at the time). But, very soon, people started to provide solutions in other &#8220;guest&#8221; languages. See for example <a href="http://blogs.perl.org/users/laurent_r/2022/07/perl-weekly-challenge-173-esthetic-number-and-sylvesters-sequence.html">my blog post</a> providing solutions to the task described below in a dozen different guest languages.</p>

<p>One of the languages I tried is <em>dc</em>, and it turned out to be much more difficult and challenging than I initially thought. I actually spent far more time on it than I would wish to admit, at least 5 to 6 hours (not counting the time to write this blog post). One of the problems is that there is only very limited documentation on this <em>old</em> programming language. So I thought it might be useful to describe in some details how I solved it.</p>

<h2>The Task</h2>

<p><em>Write a script to generate first 10 members of Sylvester&#8217;s sequence. For more informations, please refer to the <a href="https://en.wikipedia.org/wiki/Sylvester%27s_sequence">wikipedia page</a>.</em></p>

<p><em>Output:</em></p>

<pre><code>2
3
7
43
1807
3263443
10650056950807
113423713055421844361000443
12864938683278671740537145998360961546653259485195807
165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<p>Each number in the sequence is the product of all previous numbers of the sequence plus 1.</p>

<p>A potential difficulty with this problem is that we&#8217;re dealing with very large integers, so that, for some programming languages at least, we may encounter an integer overflow error (or values may be converted to floats, with a resulting loss of precision).</p>

<h2>Sylvester&#8217;s Sequence in Some Other Languages</h2>

<p>The <em>dc</em> language is difficult and poorly documented. Before we get to it, I want to illustrate the algorithm I&#8217;ll implement with some other more traditional languages.</p>

<h3>Sylvester&#8217;s Sequence in Raku</h3>

<p>Raku&#8217;s integers support arbitrary precision, so we don&#8217;t have to worry about dealing with very large integers.</p>

<p>Our first implementation reflects directly the definition: we store the Sylvester&#8217;s sequence in the <code>@s</code> array. To get a new number, we simply compute the product of all items of the <code>@s</code> array (using the <code>[*]</code> meta-operator) and add it to the array.</p>

<pre><code>my @s = 2;
while @s.elems &lt; 10 {
    push @s, 1 + [*] @s;
}
.say for @s;
</code></pre>

<p>This program displays the following output:</p>

<pre><code>$ raku ./sylvester.raku
2
3
7
43
1807
3263443
10650056950807
113423713055421844361000443
12864938683278671740537145998360961546653259485195807
165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<p>But recomputing the full product each time is inefficient. At any time through the process, the current Sylvester number is one more than the product of all previous numbers of the sequence. For example, in the output displayed above, we can compute the number of the 4th row (43) by multiplying the number of the third row (7) by it minus 1 <code>(7 - 1)</code> and adding 1 to the product: <code>7 * (7 - 1) + 1 = 43</code>. Using this recursive definition, we can write this:</p>

<pre><code>my $n = 2;
say $n;
$n = $n * ($n - 1) + 1 and say $n for 1..^10;
</code></pre>

<p>This produces the same output:</p>

<pre><code>$ ./raku sylvester3.raku
2
3
7
43
1807
3263443
[ Lines omitted for brevity ]
</code></pre>

<p>This second implementation reflects the algorithm that we will use from now on, as it has the advantage of not using arrays to store the sequence numbers.</p>

<h3>Sylvester&#8217;s Sequence in Perl</h3>

<p>Perl doesn&#8217;t natively support large integer, but we can use the <code>use BigInt;</code> pragma to convert all numeric literals to <code>Math::BigInt</code> objects, which can store arbitrarily large integers. This Perl program is essentially identical to the second Raku implementation above:</p>

<pre><code>use strict;
use warnings;
use feature "say";
use bigint;

my $n = 2;
say $n;
$n = $n * ($n - 1) + 1 and say $n for 1..9;
</code></pre>

<p>This displays the same output as before:</p>

<pre><code> $ perl sylvester3.pl
 2
 3
 7
 43
 1807
 [ Lines omitted for brevity]
 165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<h3>Sylvester&#8217;s Sequence in bc</h3>

<p>The <a href="https://en.wikipedia.org/wiki/Bc_(programming_language">bc</a>) utility, for <em>basic calculator</em>,  is &#8220;an arbitrary-precision calculator language&#8221; with syntax similar to the C programming language. It first appeared in Version 6 Unix in 1975. It is still included nowadays in most (if not all) Linux distributions. We chose to use it because of its <em>arbitrary precision</em> feature.</p>

<pre><code>n = 2
print n, "\n"
count = 1
while (count &lt; 10) {
    n = (n - 1) * n + 1
    print n, "\n"
    count += 1
}
quit
</code></pre>

<p>This displays the same output as before:</p>

<pre><code>$ BC_LINE_LENGTH=0 bc sylvester.bc
bc 1.06.95
Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation, Inc.
This is free software with ABSOLUTELY NO WARRANTY.
For details type `warranty'.
2
3
7
43
1807
[ Lines omitted fr brevity ]
165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<p>Note that we set the <code>BC_LINE_LENGTH</code> environment variable to 0 before calling <code>bc</code> to prevent bc from cutting the last line into two chunks after 70 characters. Otherwise, it would be displayed as:</p>

<pre><code>16550664732451996419846819544443918001751315270637749784185138876653\
5868639572406808911988131737645185443
</code></pre>

<p>We will see that we&#8217;ll need to do something similar with <em>dc</em>.</p>

<p>bc was initially written as a font-end to dc. As we will see, dc performs arbitrary-precision computations specified in reverse Polish notation. At the time, bc provided a conventional programming-language interface to the same capability via a simple compiler (a single yacc source file comprising a few hundred lines of code), which converted a C-like syntax into dc notation and piped the results through dc. This is in part the reason I got interested with dc.</p>

<h2>Introducing dc</h2>

<p>According to <a href="https://en.wikipedia.org/wiki/Dc_(computer_program">Wikipedia</a>), dc (desk calculator) is a cross-platform reverse-Polish calculator which supports arbitrary-precision arithmetic. Written by Lorinda Cherry and Robert Morris at Bell Labs, it is one of the oldest Unix utilities, preceding even the invention of the C programming language. Like other utilities of that vintage, it has a powerful set of features but terse syntax. Traditionally, the bc calculator program (with infix notation) was implemented on top of dc. </p>

<p>dc is the oldest surviving Unix language program. When its home Bell Labs received a PDP-11, dc—written in B—was the first language to run on the new computer, even before an assembler.</p>

<p>It uses reverse Polish notation (RPN) which was also used around the same time by Hewlett-Packard hand calculators. RPN is a postfix notation in which you first specify the operands and then the operator. </p>

<pre><code>$ echo '5 6 + p' | dc
11
</code></pre>

<p>As you can see, we first input the two operands (5 and 6), and then the <code>+</code> operator, and finally the <code>p</code> operator to print out the result of the addition. Prefix your number with an underscore if you want to specify a negative number (e.g. <code>_5</code> for -5)</p>

<p>The spaces are not needed (except between 5 and 6) but improve readability. We could have written it this way:</p>

<pre><code>$ echo '5 6+p' | dc
11
</code></pre>

<p>dc can also be used in interactive mode:</p>

<pre><code>$ dc
5 6
+
p
11
q
</code></pre>

<p>or:</p>

<pre><code>$ dc
5 6 + p q
11
</code></pre>

<p>This can be quite convenient to test chunks of code and we will use that feature.</p>

<p>We can also use the <code>-e</code> command-line option to specify a simple program:</p>

<pre><code>$ dc -e '5 6 + p'
11
</code></pre>

<p>dc uses a stack to perform its operations. The various commands above can be understood as follows:</p>

<pre><code>$ dc
5   # push 5 to stack
6   # push 6 to stack
f   # display stack (displays 6 and 5). Useful for debugging
6
5
+   # pop two items from stack, add them and push result to stack
p   # print top item of the stack (prints 11)
11
q   # quit
</code></pre>

<p>Note that the <code>#</code> sign indicates the beginning of a comment (the rest of the line is ignored).</p>

<p>For full details on the dc syntax, please consult the <a href="http://www.gnu.org/software/bc/manual/dc-1.05/html_mono/dc.html">dc GNU manual</a>. We will describe here only the command that we are likely to use for our program. The best tutorial I have found on dc is <a href="https://en.wikipedia.org/wiki/Dc_(computer_program">the Wikipedia dc page</a>).</p>

<h3>Printing Commands</h3>

<pre><code>p   Prints the value on the top of the stack, not altering the stack. 
n   Prints the value on the top of the stack, popping it off
f   Prints the entire contents of the stack without altering anything.
</code></pre>

<h3>Stack Control</h3>

<pre><code>c   Clears the stack, rendering it empty
d   duplicate the value on top of the stack
r   Reverses the order of (swaps) the top two values on the stack.
</code></pre>

<h3>Registers</h3>

<p>dc provides at least 256 memory registers, each named by a single character. You can store a number in a register and retrieve it later. </p>

<pre><code>sr  Pops the value off the top of the stack, stores it in register r. 
lr  Copies the value in register r, and pushes it onto the stack.
    This does not alter the contents of r.
</code></pre>

<p>Each register also contains its own stack. The current register value is the top of the register&#8217;s stack. </p>

<h3>Strings</h3>

<p>dc can operate on strings as well as on numbers. The only things you can do with strings are print them and execute them as macros (which means that the contents of the string are processed as dc commands). Both registers and the stack can hold strings, and dc always knows whether any given object is a string or a number.</p>

<pre><code>[ch] Makes a string containing "ch" and pushes it on the stack.
x   Pops the value from the top of the stack and executes it as a macro
&gt;r  Pops two values off the stack and compares them assuming they are 
    numbers, executing the contents of register r as a macro if the 
    original top-of-stack is greater
&lt;r  Similar but invokes the macro if the original top-of-stack is less
=r  Similar but invokes the macro if the original top-of-stack is equal
</code></pre>

<h3>Macros</h3>

<p>Macros are then implemented by allowing registers and stack entries to be strings as well as numbers. A string can be printed, but it can also be executed (i.e. processed as a sequence of dc commands). So for instance we can store a macro to add 3 and then multiply by 2 into register m:</p>

<pre><code>[3 + 2 *] sm
</code></pre>

<p>and then (using the <code>x</code> command which executes the top of the stack) we can use it like this:</p>

<pre><code>3 lm x p
</code></pre>

<p>This displays the following:</p>

<pre><code>$ dc -e '[3 + 2 *] sm 3 lm x p'
12
</code></pre>

<p>For better understanding, this is a detailed account of what&#8217;s going on:</p>

<pre><code>[   # start of macro definition
  3 # push 3 to stack
  + # pop 2 values off the stack, add them and store result on stack
  2 # push 2 on stack
  * # pop 2 values off the stack, multiply them, store result on stack
]   # end of macro definition
sm  # store the macro just defined in register m
3   # push 3 on stack
lm  # copy value in register m (the macro) onto the stack
x   # run the macro
p   # print the result (top of the stack)
</code></pre>

<p>We will look at conditionals and loops later on.</p>

<h2>Sylvester&#8217;s Sequence in dc</h2>

<p>Let&#8217;s now try to implement Sylvester&#8217;s sequence in dc.</p>

<h3>Implementing the Basic Formula</h3>

<p>Remember that we want to do something equivalent to this Raku program:</p>

<pre><code>my $n = 2;
say $n;
$n = $n * ($n - 1) + 1 and say $n for 1..^10;
</code></pre>

<p>We will do it mostly in interactive mode.</p>

<p>First, we want to give an initial value of 2 to n and print it.</p>

<pre><code>$ dc
2snlnp
2
</code></pre>

<p>This is a detailed description of the cryptic <code>2snlnp</code> command:</p>

<pre><code>2    # push 2 on stack
sn   # pops 2 from stack and store in register n
ln   # copy register n onto stack
p    # print top of stack
</code></pre>

<p>We could make it one character shorter by using the <code>d</code> duplicate command:</p>

<pre><code>$ dc -e '2dsnp'
2
</code></pre>

<p>Then, we want to implement and test the <code>$n = $n * ($n - 1) + 1</code> formula:</p>

<pre><code>2snlnp
2
1-   # subtract 1 from stack
ln   # load n on stack
*1+p # compute product, add 1 and print new value
3    
sn   # pop new value and store it in register n
ln   # copy new value in n to stack
</code></pre>

<p>So, <code>n</code> was 2 and is now set to 3. This is the expected result, so it looks promising. Let&#8217;s run again that series of commands a couple of times:</p>

<pre><code>$ dc
2snlnp
2
1-   # subtract 1 from stack
ln   # load n on stack
*1+p # compute product, add 1 and print new value
3
sn   # pop new value and store it in register n
ln   # copy new value in n to stack
1-   # subtract 1 from stack
ln   # load n on stack
*1+p # compute product, add 1 and print new value
7
sn   # pop new value and store it in register n
ln   # copy new value in n to stack
1-   # subtract 1 from stack
ln   # load n on stack
*1+p # compute product, add 1 and print new value
43
sn   # pop new value and store it in register n
ln   # copy new value in n to stack
1-   # subtract 1 from stack
ln   # load n on stack
*1+p # compute product, add 1 and print new value
1807
</code></pre>

<p>We obtain the proper sequence of Sylvester numbers: 2, 3, 7, 43, 1807. But, of course, it is a pain in the neck to repeatedly enter this series of 5 commands. We can store it in a macro (I used register <code>m</code>, m as the first letter in macro, because it makes it easier to remember, but you could store a macro in any other register) and then execute the macro any number of times:</p>

<pre><code>$ dc
2snlnp                 # initialization of n to 2
2
[1- ln *1+p sn ln]sm   # store the macro in register m
lm x                   # run the macro
3
lm x
7
lm x
43
lm x
1807
lm x
3263443
lm x
10650056950807
...
</code></pre>

<p>So, the results are correct, we have the basic actions to compute the Sylvester&#8217;s sequence. We still have to implement a loop to automatize macro execution a given number of times.</p>

<h3>Conditionals and Loops in dc</h3>

<p>The <code>=</code>, <code>&gt;</code>, <code>!&gt;</code>, <code>&lt;</code>, <code>!&lt;</code>, <code>!=</code> conditionals execute the subsequent macro when the two top values of the stack are equal, larger than, not larger than, etc. For example, in:</p>

<pre><code>$ dc -e '[[smaller than]p] sm 6 5 &lt;m'
smaller than
</code></pre>

<p>the macro stored in <code>m</code> runs (and prints &#8220;smaller than&#8221;) because 5 is smaller than 6. The <code>&lt;</code> pops 5 and then 6 from the stack and runs the macro in register <code>m</code> because the first popped value (5) is smaller than the second popped value.</p>

<p>The above-mentioned Wikipedia page then states: &#8220;Looping is then possible by defining a macro which (conditionally) reinvokes itself. A simple factorial of the top of the stack might be implemented as: </p>

<pre><code>[d1-d1&lt;F*]dsFxp
</code></pre>

<p>I must admit that I did not understand it when I first read it. And still not when I read it a second time and then a third time.</p>

<p>Let&#8217;s get away from the Sylvester sequence for a brief moment and look at a simple countdown in <a href="https://wiki.bash-hackers.org/howto/calculate-dc">this page</a> in the Bash Hackers Wiki:</p>

<pre><code>dc &lt;&lt; EOF
[ li       # put our index i on the stack 
  p        # print it, to see what's going on
  1 -      # we decrement the index by one
  si       # store decremented index (i=i-1)
 0 li &gt;L   # if i &gt; 0 then execute L
] sL       # store our macro with the name L
10 si      # let's give to our index the value 10
lLx        # and start our loop
EOF 

10
9
8
[ lines omitted for brevity]
2
1
</code></pre>

<p>OK, now I understand it (and I suppose you will if you read the detailed comments) and can complete the task. </p>

<h3>The Complete Sylvester Program in dc</h3>

<p>This is now the full Sylvester&#8217;s sequence program in dc:</p>

<pre><code>2sn     # push 2 on the stack, pop 2 off the top of the stack
        # and store it into register n
lnp     # copy the value back on the stack and print it
9sc     # give counter c an initial value of 9
[       # start of macro
  1-    # subtract 1 from stack (value n-1)
  ln    # load n to stack
  *1+p  # compute product n * n-1, add 1 and print
  sn    # pop new value and store it in register n
  ln    # copy new value in  n to stack
  lc    # copy counter to stack
  1-    # decrement counter (subtract 1 from c)
  sc    # store decremented counter in c
  0 lc  # store 0 and counter on stack
  &gt;m    # compare c to 0 and, if c &gt; 0, run recursively macro in m
]       # end of macro
d       # duplicate macro on stack
sm      # store macro in register m
x       # execute first iteration of macro
</code></pre>

<p>To run it and display properly the last line, we need to set the <code>DC_LINE_LENGTH</code> to 0 in a way similar to what we had to do with bc..</p>

<pre><code>$  DC_LINE_LENGTH=0 dc sylvester.dc
2
3
7
43
1807
3263443
10650056950807
113423713055421844361000443
12864938683278671740537145998360961546653259485195807
165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<p>But, of course, formatting the program with spaces and comments as above is way too easy and good only for wimps and cowards. Real programmers will prefer this one-line version:</p>

<pre><code>2snlnp9sc[1-ln*1+psnlnlc1-sc0lc&gt;m]dsmx
</code></pre>

<p>which you can run as follows:</p>

<pre><code>$ echo '2snlnp9sc[1-ln*1+psnlnlc1-sc0lc&gt;m]dsmx
       ' |  DC_LINE_LENGTH=0 dc
2
3
7
43
1807
3263443
10650056950807
113423713055421844361000443
12864938683278671740537145998360961546653259485195807
165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<h2>Wrapping up</h2>

<p>The next week Perl Weekly Challenge will start soon. If you want to participate in this challenge, please check https://perlweeklychallenge.org/ and make sure you answer the challenge before 23:59 BST (British summer time) on July 24, 2022. And, please, also spread the word about the Perl Weekly Challenge if you can.</p>
]]>
        

    </content>
</entry>
  <entry>
    <title>Perl Weekly Challenge 173: Esthetic Number and Sylvester's Sequence</title>
    <link rel="alternate" href="http://blogs.perl.org/users/laurent_r/2022/07/perl-weekly-challenge-173-esthetic-number-and-sylvesters-sequence.html"/>
    <id>tag:blogs.perl.org,2022:/users/laurent_r//3226.10847</id>
    <published>2022-07-11T19:08:25Z</published>
    <updated>2022-07-16T21:17:57Z</updated>
    <author>
        <name>laurent_r</name>
        <uri>https://laurent-rosenfeld.developpez.com/</uri>
    </author>
    <content type="html" xml:lang="en" xml:base="http://blogs.perl.org/users/laurent_r/">
        <![CDATA[<p>These are some answers to the Week 173 of the <a href="https://perlweeklychallenge.org/blog/perl-weekly-challenge-173/">Perl Weekly Challenge</a> organized by <a href="http://blogs.perl.org/users/mohammad_s_anwar/">Mohammad S. Anwar</a>.</p>

<p><em>Spoiler Alert:</em> This weekly challenge deadline is due in a few of days from now (on July 17, 2022 at 23:59). This blog post offers some solutions to this challenge, please don’t read on if you intend to complete the challenge on your own.</p>

<h2>Task 1: Esthetic Number</h2>

<p><em>You are given a positive integer, <code>$n</code>.</em></p>

<p><em>Write a script to find out if the given number is Esthetic Number.</em></p>

<blockquote>
  <p><em>An esthetic number is a positive integer where every adjacent digit differs from its neighbour by 1.</em></p>
</blockquote>

<p><em>For example,</em></p>

<pre><code>5456 is an esthetic number as |5 - 4| = |4 - 5| = |5 - 6| = 1
120 is not an esthetic numner as |1 - 2| != |2 - 0| != 1
</code></pre>

<h3>Esthetic Number in Raku</h3>

<p>We write an <code>is-esthetic</code> subroutine which splits the input number into an array of digits and checks, for each digit, whether the absolute value of its difference with the previous one is equal to 1. The subroutine returns <code>False</code> is this value is not 1. If it loops through the end, it returns True.</p>

<pre><code>sub is-esthetic ($n) {
    my @d = $n.comb;     # get an array of digits
    return False if abs(@d[$_] - @d[$_-1]) != 1 for 1..@d.end;
    return True;
}
for &lt;5456 120 121 23456 2346 7654567 765467&gt; -&gt; $test {
    say $test.fmt("%-9d"), is-esthetic($test) ?? "is esthetic" !! "is not esthetic";
}
</code></pre>

<p>This program displays the following output:</p>

<pre><code>$ raku ./esthetic_nums.raku
5456     is esthetic
120      is not esthetic
121      is esthetic
23456    is esthetic
2346     is not esthetic
7654567  is esthetic
765467   is not esthetic
</code></pre>

<h3>Esthetic Number in Perl</h3>

<p>This is a port to Perl of the previous Raku program, with an <code>is_esthetic</code> subroutine returning 0 (false value) if the absolute value of the difference between two adjacent digits is not equal to 1.</p>

<pre><code>use strict;
use warnings;
use feature "say";

sub is_esthetic {
    my @d = split //, shift;     # get an array of digits
    for my $i (1..$#d) {
        return 0 if abs($d[$i] - $d[$i -1 ]) != 1;
    }
    return 1;
}
for my $test (qw&lt;5456 120 121 23456 2346 7654567 765467&gt;) {
    say sprintf("%-9d", $test), is_esthetic($test) ? "is esthetic" : "is not esthetic";
}
</code></pre>

<p>This program displays the following output:</p>

<pre><code>$ perl ./esthetic_nums.pl
5456     is esthetic
120      is not esthetic
121      is esthetic
23456    is esthetic
2346     is not esthetic
7654567  is esthetic
765467   is not esthetic
</code></pre>

<h3>Esthetic Number in Julia</h3>

<p>In Julia, you can use subscripts to access individual characters of a string:</p>

<pre><code>julia&gt; print("hello World"[5])    # Scala subscripts start at 1
o
</code></pre>

<p>You cannot do that in Perl and in Raku. Well, in Raku, you could implement your own postcircumfix <code>[...]</code> operator like this:</p>

<pre><code>multi sub postcircumfix:&lt;[ ]&gt; (Str $s, Int $n) {
    substr-rw $s, $n, 1;
}
</code></pre>

<p>but it doesn&#8217;t seem to be worth the trouble for such a simple program.</p>

<p>Anyway since subscript can be used for that purpose in Scala, I decided that my program could easily traverse the string representation of the candidate number, without having to split it into an array of individual digits. All we need to do is to coerce the input number into a string.</p>

<pre><code>function is_esthetic(num)
    n = string(num)
    for i in 2:length(n)
        if abs(n[i] - n[i-1]) != 1
            return false
        end
    end
    return true
end

for test in [5456, 120, 121, 23456, 2346, 7654567, 765467]
    println("$test\t", is_esthetic(test) ? "Esthetic" : "Non esthetic")
end
</code></pre>

<p>It may not be obvious, but there is quite a bit of magic going on in this line:</p>

<pre><code>if abs(n[i] - n[i-1]) != 1
</code></pre>

<p><code>n[i]</code> and <code>n[i+1]</code> don&#8217;t contain digits, but characters representing digits (ASCII representation). For example, if we are processing a <code>'1'</code> character, we are processing ASCII char 49. So, perhaps, we should convert them to integers:</p>

<pre><code>if abs(Int(n[i]) - Int(n[i-1])) != 1
</code></pre>

<p>Well, still not quite good. If the number being tested if 12, the line above would compare integers 49 (char <code>’1’</code>) and 50 (char <code>’2’</code>), not numbers 1 and 2. To really compare 1 and 2, we would have to subtract <code>Int['0']</code> (48) from each term:</p>

<pre><code>if abs((Int(n[i]) - Int('0')) - (Int(n[i-1] - Int('0'))) != 1
</code></pre>

<p>Of course, subtracting <code>Int('0')</code> (48) from both terms of a subtraction is useless, as the result will be unchanged. But, more broadly, we don&#8217;t need to go through the trouble of casting the chars to ints, because Julia can easily compute the numerical difference between two characters. It even works with non-numerical characters such as letters:</p>

<pre><code>julia&gt; print('e' - 'c')
2
</code></pre>

<p>Output:</p>

<pre><code>$ julia ./esthetic_nums.jl
5456    Esthetic
120     Non esthetic
121     Esthetic
23456   Esthetic
2346    Non esthetic
7654567 Esthetic
765467  Non esthetic
</code></pre>

<h3>Esthetic Number in Python</h3>

<p>In Python, you can also use subscripts to access individual characters of a string, so I chose to also traverse the string representation of the input integer. But it turned out to be a bit more complicated than in Julia. In Python, we need to cast the individual characters into integers to make the subtraction possible.</p>

<pre><code>def is_esthetic(m):
  n = str(m)
  for i in range(1, len(n)):
    if abs(int(n[i]) - int(n[i - 1 ])) != 1:
      return False
  return True

for test in [5456, 120, 121, 23456, 2346, 7654567, 765467]:
  if is_esthetic(test):
    print("{:&lt;9d} is esthetic".format(test))
  else:
    print("{:&lt;9d} is not esthetic".format(test))
</code></pre>

<p>Output:</p>

<pre><code>$ python3 ./esthetic_nums.py
5456      is esthetic
120       is not esthetic
121       is esthetic
23456     is esthetic
2346      is not esthetic
7654567   is esthetic
765467    is not esthetic
</code></pre>

<h3>Esthetic Number in Ruby</h3>

<p>Like in Python, we need to cast characters to integers to make the subtraction possible in Ruby:</p>

<pre><code>def is_esthetic(m)
    n = m.to_s
    for i in 1..(n.length - 1)
        if (n[i].to_i - n[i-1].to_i).abs != 1
            return false
        end
    end
    return true
end

for test in [ 5456, 120, 121, 23456, 2346, 7654567, 765467]
    printf "%-9d ", test 
    if is_esthetic(test)
        print("is esthetic\n")
    else
        print("is not esthetic\n")
    end
end
</code></pre>

<p>Output:</p>

<pre><code>5456      is esthetic
120       is not esthetic
121       is esthetic
23456     is esthetic
2346      is not esthetic
7654567   is esthetic
765467    is not esthetic
</code></pre>

<h3>Esthetic Number in Ring</h3>

<p>Like in Julia, there is no need to cast characters to integers in Ring:</p>

<pre><code>for test in [5456, 120, 121, 23456, 2346, 7654567, 765467]
    see test
    if is_esthetic(test)
        see " is esthetic" + nl
    else
        see " is not esthetic" + nl
    ok
next

func is_esthetic (num)
    n = "" + num
    for i = 2 to len(n)
        if fabs(n[i] - n[i-1]) != 1
            return false
        ok
    next
    return true
</code></pre>

<p>Output:</p>

<pre><code>$ ring ./esthetic_nums.ring
5456 is esthetic
120 is not esthetic
121 is esthetic
23456 is esthetic
2346 is not esthetic
7654567 is esthetic
765467 is not esthetic
</code></pre>

<h3>Esthetic Number in Kotlin</h3>

<pre><code>import kotlin.math.abs

fun is_esthetic(num: Int): Boolean {
    val n = num.toString()
    for (i in 1..n.length - 1) {
        if (abs(n[i] - n[i-1]) != 1) {
            return false
        }
    }
    return true
}
fun main() {
    for (test in arrayOf(5456, 120, 121, 23456, 2346, 7654567, 765467)) {
        if (is_esthetic(test)) {
            println("$test is esthetic")
        } else {
            println("$test is not esthetic")
        }
    }
}
</code></pre>

<p>Output:</p>

<pre><code>5456 is esthetic
120 is not esthetic
121 is esthetic
23456 is esthetic
2346 is not esthetic
7654567 is esthetic
765467 is not esthetic
</code></pre>

<h3>Esthetic Number in Go</h3>

<pre><code>package main

import (
    "fmt"
    "strconv"
)

func is_esthetic(n int) bool {
    s := strconv.Itoa(n)
    for i := 1; i &lt; len(s); i++ {
        if s[i]-s[i-1] != 1 &amp;&amp; s[i-1]-s[i] != 1 {
            return false
        }
    }
    return true
}
func main() {
    tests := []int{5456, 120, 121, 23456, 2346, 7654567, 765467}
    for _, test := range tests {
        if is_esthetic(test) {
            fmt.Printf("%-9d is esthetic\n", test)
        } else {
            fmt.Printf("%-9d is not esthetic\n", test)
        }
    }
}
</code></pre>

<p>Output:</p>

<pre><code>5456      is esthetic
120       is not esthetic
121       is esthetic
23456     is esthetic
2346      is not esthetic
7654567   is esthetic
765467    is not esthetic
</code></pre>

<h3>Esthetic Number in D</h3>

<pre><code>import std.stdio;
import std.math;
import std.conv;

bool is_esthetic(int num) {
    auto s = to!string(num, 10);
    foreach (i; 1 .. s.length) {
        if (abs(s[i] - s[i-1]) != 1) return false;
    }
    return true;
}
void main() {
    int[] tests = [ 5456, 120, 121, 23456, 2346, 7654567, 765467 ];
    foreach(test; tests) {
        printf("%-9d ", test);
        if (is_esthetic(test)) {
            writeln("is esthetic");
        } else {
            writeln("is not esthetic");
        }
    }
}
</code></pre>

<p>Output:</p>

<pre><code>5456      is esthetic
120       is not esthetic
121       is esthetic
23456     is esthetic
2346      is not esthetic
7654567   is esthetic
765467    is not esthetic
</code></pre>

<h3>Esthetic Number in Nim</h3>

<pre><code>import strutils
import std/strformat

proc is_esthetic(num: int): bool =
  let n = intToStr(num)
  for i in 1..len(n)-1:
    if abs(int(n[i]) - int(n[i-1])) != 1:
      return false
  return true

for test in [5456, 120, 121, 23456, 2346, 7654567, 765467]:
  if is_esthetic(test):
    echo fmt("{test:&lt;9}"), " is esthetic"
  else:
    echo fmt("{test:&lt;9}"), " is not esthetic"
</code></pre>

<p>Output:</p>

<pre><code>5456      is esthetic
120       is not esthetic
121       is esthetic
23456     is esthetic
2346      is not esthetic
7654567   is esthetic
765467    is not esthetic
</code></pre>

<h2>Task 2: Sylvester&#8217;s Sequence</h2>

<p><em>Write a script to generate first 10 members of Sylvester&#8217;s sequence. For more informations, please refer to the <a href="https://en.wikipedia.org/wiki/Sylvester%27s_sequence">wikipedia page</a>.</em></p>

<p><em>Output:</em></p>

<pre><code>2
3
7
43
1807
3263443
10650056950807
113423713055421844361000443
12864938683278671740537145998360961546653259485195807
165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<p>Each number in the sequence is the product of all previous numbers of the sequence plus 1.</p>

<p>The only potential difficulty with this problem is that we&#8217;re dealing with very large integers so that, for some programming languages at least, we may encounter an integer overflow error (or values may be converted to floats, with a resulting loss of precision).</p>

<h3>Sylvester&#8217;s Sequence in Raku</h3>

<p>In Raku, <code>Int</code> objects store integral numbers of <em>arbitrary</em> size. So we don&#8217;t have to worry about very large integers.</p>

<p>We start with a direct implementation of the definition. We store the sequence in the <code>@s</code> array. To get a new  number, we simply compute the product of all items of the <code>@s</code> array (using the <code>[*]</code> meta-operator) and add it to the array.</p>

<pre><code>my @s = 2;
while @s.elems &lt; 10 {
    push @s, 1 + [*] @s;
}
.say for @s;
</code></pre>

<p>This program displays the following output:</p>

<pre><code>$ raku ./sylvester.raku
2
3
7
43
1807
3263443
10650056950807
113423713055421844361000443
12864938683278671740537145998360961546653259485195807
165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<p>The program runs very fast, but is not as efficient as it could be because we are performing some of the multiplications many times. When computing <code>@s[$n+1]</code>, we know that <code>@s[$n]</code> contains the product of all values between <code>@s[0]</code> and <code>@s[$n-1]</code> plus 1. Therefore, the <code>n + 1</code> item of the sequence can be defined recursively as <code>@s[$n] * (@s[$n] - 1) + 1</code>, so that we can perform only one multiplication each time. This can lead to the following modified implementation:</p>

<pre><code>my @n = 2;
push @n, @n[*-1] * (@n[*-1] - 1) + 1 for 1..^10;
.say for @n;
</code></pre>

<p>This program displays the same output as above:</p>

<pre><code>$ raku ./sylvester2.raku
2
3
7
43
1807
(lines omitted for brevity)
</code></pre>

<h3>Sylvester&#8217;s Sequence in Perl</h3>

<p>In Perl, scalars cannot contain such large integers. But we can use the <code>use BigInt;</code> pragma to convert all numeric literals to <code>Math::BigInt</code>, which can store arbitrarily large integers.</p>

<p>To port the first raku program above to Perl, we implement a <code>prod</code> subroutine that computes the product of all items of its input.</p>

<pre><code>use strict;
use warnings;
use feature "say";
use bigint;

sub prod {
    my $prod = 1;
    $prod *= $_ for @_;
    return $prod;
}

my @s = (2);
while (@s &lt; 10) {
    push @s, 1 + prod @s;
}
say for @s;
</code></pre>

<p>This program displays the following output:</p>

<pre><code>$ perl ./sylvester.pl
2
3
7
43
1807
3263443
10650056950807
113423713055421844361000443
12864938683278671740537145998360961546653259485195807
165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<p>We can avoid the <code>prod</code> subroutine if we use the method of the second Raku program above:</p>

<pre><code>use strict;
use warnings;
use feature "say";
use bigint;

my @s = (2);
push @s, $s[-1] * ($s[-1] - 1) + 1 for 1..9;
say for @s;
</code></pre>

<p>This program displays the same output:</p>

<pre><code>$ perl ./sylvester2.pl
2
3
7
43
1807
(lines omitted for brevity)
</code></pre>

<h3>Sylvester&#8217;s Sequence in bc</h3>

<p>The Unix <code>bc</code> utility is an <em>arbitrary</em> precision calculator language, so it is tempting to use it for a problem in which the only potential difficulty is the use of very large integers. However, <code>bc</code>&#8217;s arrays lack many of the cool features of more modern languages. We will implement the second method above without using any array (printing the values as we compute them).</p>

<pre><code>n = 2
print n, "\n"
count = 1
while (count &lt; 10) {
    n = (n - 1) * n + 1
    print n, "\n"
    count += 1
}
quit
</code></pre>

<p>This script displays the following output:</p>

<pre><code>$ bc ./sylvester.bc
bc 1.06.95
Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation, Inc.
This is free software with ABSOLUTELY NO WARRANTY.
For details type `warranty'.
2
3
7
43
1807
3263443
10650056950807
113423713055421844361000443
12864938683278671740537145998360961546653259485195807
16550664732451996419846819544443918001751315270637749784185138876653\
5868639572406808911988131737645185443
</code></pre>

<p>One last little problem here is that bc cannot print numbers larger than 70 digits on the same line, so that the last Sylvester number above is cut over two lines. We can pipe the bc output through a Perl one-line filter (or some other utility) to reformat properly the faulty line:</p>

<pre><code>$ bc sylvester.bc | perl -pe 's/\\\s//'
2
3
7
43
1807
3263443
10650056950807
113423713055421844361000443
12864938683278671740537145998360961546653259485195807
165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<p>Another way is to set the <code>BC_LINE_LENGTH</code> environment variable to 0:</p>

<pre><code>$ BC_LINE_LENGTH=0 bc sylvester.bc
bc 1.06.95
Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation, Inc.
This is free software with ABSOLUTELY NO WARRANTY.
For details type `warranty'.
2
3
7
43
1807
3263443
10650056950807
113423713055421844361000443
12864938683278671740537145998360961546653259485195807
165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<h3>Sylvester&#8217;s Sequence in dc</h3>

<p>The Unix <code>dc</code> utility is also an <em>arbitrary</em> precision calculator language, so it is tempting to use it for a problem in which the only potential difficulty is the use of very large integers. In fact, bc used to be a standard infix front-end to the dc reverse Polish notation.</p>

<p>This is a dc program to display the first 10 elements of the Sylvester&#8217;s sequence:</p>

<pre><code>2snlnp9sc[1-ln*1+psnlnlc1-sc0lc&gt;m]dsmx
</code></pre>

<p>You can run it as follows:</p>

<pre><code>$ echo '2snlnp9sc[1-ln*1+psnlnlc1-sc0lc&gt;m]dsmx
       ' |  DC_LINE_LENGTH=0 dc
2
3
7
43
1807
3263443
10650056950807
113423713055421844361000443
12864938683278671740537145998360961546653259485195807
165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<p>OK, I must admit that I golfed it. I usually try to use concise syntax, but don&#8217;t commonly golf my solutions. Here, I think that I probably deserve an award for the shortest and most obfuscated golf piece for that problem.</p>

<p>This is now a much more readable version of the same solution:</p>

<pre><code>2sn     # push 2 on the stack, pop 2 off the top of the stack and store it into register n
lnp     # copy the value back on the stack and print it
9sc     # give counter c an initial value of 9
[       # start of macro
  1-    # subtract 1 from stack (value n-1)
  ln    # load n to stack
  *1+p  # compute product n * n-1, add 1 and print
  sn    # pop new value and store it in register n
  ln    # copy new value in  n to stack
  lc    # copy counter to stack
  1-    # decrement counter (subtract 1 from c)
  sc    # store decremented counter in c
  0 lc  # store 0 and counter on stack
  &gt;m    # compare counter to 0 and, if c &gt; 0, run recursively macro in m
]       # end of macro
d       # duplicate macro
sm      # store macro in register m
x       # execute first iteration of macro
</code></pre>

<p>Understanding the solution in details would require a lot more explanations than what I can provide here. You are kindly invited to read <a href="http://blogs.perl.org/users/laurent_r/2022/07/perl-weekly-challenge-173-sylvesters-sequence-in-dc.html">this other blog post</a> where I describe in detail how I solved the problem in dc.</p>

<h3>Sylvester&#8217;s Sequence in Julia</h3>

<p>With regular integers, we obtain totally wrong results, including negative integers and so forth. All we need to do to fix that problem is to declare our initial variable as a <code>BigInt</code>:</p>

<pre><code>s = BigInt(2)
println(s)
for i in 1:9
    s = s * (s - 1) + 1
    println(s)
end
</code></pre>

<p>Output:</p>

<pre><code>$ julia ./sylvester.jl
2
3
7
43
1807
3263443
10650056950807
113423713055421844361000443
12864938683278671740537145998360961546653259485195807
165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<h3>Sylvester&#8217;s Sequence in Python</h3>

<p>Recent versions of Python automatically switch to big integers when needed:</p>

<pre><code>s = [2];
for i in range(9):
  s.append(s[-1] * (s[-1] - 1) + 1)
for j in s:
  print(j)
</code></pre>

<p>Output:</p>

<pre><code>$ python3 sylvester.py
2
3
7
43
1807
3263443
10650056950807
113423713055421844361000443
12864938683278671740537145998360961546653259485195807
165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<h3>Sylvester&#8217;s Sequence in Ruby</h3>

<pre><code># Ruby automatically switches to Bignum when needed
s = 2
print("#{s}\n")
for i in 1..9
    s = s * (s - 1) + 1
    print("#{s}\n")
end
</code></pre>

<p>Output:</p>

<pre><code>2
3
7
43
1807
3263443
10650056950807
113423713055421844361000443
12864938683278671740537145998360961546653259485195807
165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<h3>Sylvester&#8217;s Sequence in Ring</h3>

<p>As far as I can tell, Ring doesn&#8217;t have a BigNum package. But Ring gracefully switches to floating point arithmetics and thus produces fairly decent approximations of the expected result.</p>

<pre><code>s = 2;
see s + nl
for i = 1 to 9
    s = s * (s - 1) + 1
    see s + nl
next
</code></pre>

<p>Output:</p>

<pre><code>$ ring ./sylvester.ring
2
3
7
43
1807
3263443
10650056950807
113423713055421845118910464.00
12864938683278672079501004830742670366487445279604736.00
1.655066473245199625930595525909356695752320791312711997146979916612453687017861571473280717e+104
</code></pre>

<p>The three last Sylvester numbers above are computed with floating point arithmetics. As you can see if you compare with the results obtained with other languages above, only the first 16th to 17th digits are accurate.</p>

<h3>Sylvester Sequence in Scala</h3>

<p>Like in Julia, we only need to declare our initial variable as a <code>BigInt</code> to get the correct results in Scala:</p>

<pre><code>object sylvester extends App {
  var n = BigInt(2)
  println(n)
  for (i &lt;- 1 to 9) {
    n = n * (n - 1) + 1
    println(n)
  }
}
</code></pre>

<p>Output:</p>

<p>2
3
7
43
1807
3263443
10650056950807
113423713055421844361000443
12864938683278671740537145998360961546653259485195807
165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443</p>

<h3>Sylvester&#8217;s Sequence in Kotlin</h3>

<p>In Kotlin, we import the java <code>java.math.BigInteger</code> library. Note that it doesn&#8217;t know how to mix <code>BigInteger</code> numbers with standard integers in computations, so we need to create <code>one</code>, a <code>BigInteger</code> for 1.</p>

<pre><code>import java.math.BigInteger

fun main () {
    var n = BigInteger("2")
    val one = BigInteger("1")
    for (i in 1..9) {
        n = n * (n - one) + one
        println(n)
    }
}
</code></pre>

<p>Output:</p>

<pre><code>3
7
43
1807
3263443
10650056950807
113423713055421844361000443
12864938683278671740537145998360961546653259485195807
165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<h3>Sylvester&#8217;s Sequence in D</h3>

<pre><code>import std.stdio;
import std.bigint;

void main() {
    BigInt s = "2";
    writeln(s);
    for (int i = 1; i &lt;= 9; i++) {
        s = s * (s - 1) + 1;
        writeln(s);
    }
}
</code></pre>

<p>Output:</p>

<pre><code>2
3
7
43
1807
3263443
10650056950807
113423713055421844361000443
12864938683278671740537145998360961546653259485195807
165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<h3>Sylvester&#8217;s Sequence in Lua</h3>

<p>I did not succeed to use the library for large integers. Perhaps my Lua installation is faulty, or I missed something else. I still want to show the result to illustrate how wrong a program can go in the event of an integer overflow not properly managed. We&#8217;ve seen before that Ring (for example) automatically switches to floats and provides results accurate to the first 16 decimal places. In Lua, this goes horribly wrong, and displays even negative integers.</p>

<pre><code>-- Does not work properly
s = 2
print(s)
for i = 1, 9 do
    s = s * (s - 1) + 1
    print(s)
end
</code></pre>

<p>Output:</p>

<pre><code>2
3
7
43
1807
3263443
10650056950807
-3591524960174918149
-8362769992138052065
4108952388197251491
</code></pre>

<h3>Sylvester&#8217;s Sequence in Go</h3>

<p>This works properly, but the method-invocation syntax for using big integers in Go is just plainly horrible and very difficult to use. I expected better from one of the world&#8217;s largest and wealthiest corporations and some legendary computer scientists, especially when it is claimed that Go was designed to be simple. OK, I must admit that it is still simpler than dc (see above), but dc was designed and written almost half a century ago.</p>

<pre><code>// Go big int syntax really sucks
package main

import (
    "fmt"
    "math/big"
)

func main() {
    s := big.NewInt(2)
    fmt.Println(0, ": ", s)
    one := big.NewInt(1)
    for i := 1; i &lt;= 9; i++ {
        s.Add(new(big.Int).Mul(s, s), new(big.Int).Sub(one, s))
        fmt.Println(i, ": ", s)
    }
}
</code></pre>

<p>Output:</p>

<pre><code>0 :  2
1 :  3
2 :  7
3 :  43
4 :  1807
5 :  3263443
6 :  10650056950807
7 :  113423713055421844361000443
8 :  12864938683278671740537145998360961546653259485195807
9 :  165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<h3>Sylvester&#8217;s Sequence in Nim</h3>

<pre><code>import bigints

var s = 2.initBigInt
echo s
for i in 1..9:
    s = s * (s - 1) + 1
    echo s
</code></pre>

<p>Output:</p>

<pre><code>2
3
7
43
1807
3263443
10650056950807
113423713055421844361000443
12864938683278671740537145998360961546653259485195807
165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<h3>Sylvester&#8217;s Sequence in Dart</h3>

<p>Like in Kotlin, <code>BigInt</code> objects don&#8217;t mix in properly with regular integers in Dart. So we need to declare a <code>one</code> BigInt object for integer 1.</p>

<p>void main() {
    var s = BigInt.from(2);
    print(s);
    var one = BigInt.from(1);
    for (int i = 1; i &lt;= 9; i++) {
        s = s * (s - one) + one;
        print(s);
    }
}</p>

<p>Output:</p>

<pre><code>2
3
7
43
1807
3263443
10650056950807
113423713055421844361000443
12864938683278671740537145998360961546653259485195807
165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<h3>Sylvester&#8217;s Sequence in JavaScript</h3>

<p>Here, again, we need to declare a <code>one</code> <code>BigInt</code> object for integer 1.</p>

<pre><code>let s = BigInt (2)
let one = BigInt (1)
console.log(s + " ");
for (let i = 1; i &lt;= 9; i++) {
    s = s * (s - one) + one
    console.log(s + " ");
}
</code></pre>

<p>Output:</p>

<pre><code>2 
3 
7 
43 
1807 
3263443 
10650056950807 
113423713055421844361000443 
12864938683278671740537145998360961546653259485195807 
165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<h3>Sylvester&#8217;s Sequence in TCL</h3>

<p>TCL natively supports arbirarily large integers.</p>

<pre><code>set s 2
puts $s
for {set i 1} {$i &lt;= 9} {incr i} {
    set s [expr ($s * ($s - 1) + 1)]
    puts $s
}
</code></pre>

<p>Output:</p>

<pre><code>2
3
7
43
1807
3263443
10650056950807
113423713055421844361000443
12864938683278671740537145998360961546653259485195807
165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185443
</code></pre>

<h2>Wrapping up</h2>

<p>The next week Perl Weekly Challenge will start soon. If you want to participate in this challenge, please check https://perlweeklychallenge.org/ and make sure you answer the challenge before 23:59 BST (British summer time) on July 24, 2022. And, please, also spread the word about the Perl Weekly Challenge if you can.</p>
]]>
        

    </content>
</entry>
  <entry>
    <title>The CPAN Testers game</title>
    <link rel="alternate" href="http://blogs.perl.org/users/alceu_rodrigues_de_freitas_junior/2022/07/the-cpan-testers-game.html"/>
    <id>tag:blogs.perl.org,2022:/users/alceu_rodrigues_de_freitas_junior//2672.10849</id>
    <published>2022-07-14T01:13:49Z</published>
    <updated>2022-07-14T02:21:47Z</updated>
    <author>
        <name>Alceu Rodrigues de Freitas Junior</name>
        <uri>https://github.com/glasswalk3r</uri>
    </author>
    <category term="cpan" label="cpan" scheme="http://www.sixapart.com/ns/types#tag"/>
    <content type="html" xml:lang="en" xml:base="http://blogs.perl.org/users/alceu_rodrigues_de_freitas_junior/">
        <![CDATA[<p>I'm not sure of how many of you know the ecosystem of Perl QA, so I decided to move an old article of mine to medium.com and update it to reflect all the changes that happened between those years.</p>

<p>Here is <a href="https://medium.com/@alceu.freitas.jr/the-cpan-testers-game-e09a260c6008">the link to the old-new article</a>.</p>

<p>I also made several changes to the project <a href="https://github.com/glasswalk3r/cpan-openbsd-smoker">cpan-openbsd-smoker</a> and would like to share with the community the details about it, specially with the people that not only publishes modules to CPAN, but also those are part (or want to be part of) the QA group.</p>

<p><big>The CPAN OpenBSD Smoker project</big></p>

<p>This project basically applies a lot of documented steps scattered around and produces an local VM running OpenBSD with a running CPAN Smoker in an automated fashion.</p>

<p>In the first versions, much of the automation was implemented with Bash scripts. Later, I started introducing Perl code to replace the scripts that become more complex. Then I added <a href="http://savannah.gnu.org/projects/parallel">parallel</a> to the mix and things started getting really complicated.</p>

<p>Not surprisingly, I replaced almost everything with Ansible and although some features were discarded during the process, the project now is much easier to understand and maintain.</p>

<p>Currently I'm considering writing a more generic Ansible role to allow the setup of a CPAN Smoker in not only OpenBSD, but all OSes that supports Perl and Ansible itself.</p>

<p><big>Why Ansible?</big></p>

<p>Since the beginning of the project I was using Vagrant. Adding Packer to the mix followed quickly because it helped putting a lot of effort in creating a base Vagrant box, which speed up the provisioning process greatly.</p>

<p>Adding Ansible to the mix with Vagrant and Packer was really easy.</p>

<p>First because I already knew Ansible. Second, because it was nicely integrated with both tools. Third, many of what I was implementing with my own code already exists ready to use as Ansible modules and roles.</p>

<p>I already asked myself if I shouldn't try to use <a href="https://www.rexify.org/">Rex</a> instead, since is written in Perl and all this work is to help the Perl ecosystem.</p>

<p>As I stated before, I already know Ansible. While I think Rex might do the same things, I'm not sure about. And since I need to have it integrated with Packer and Vagrant (the first is written in Golang, the second in Ruby) I believe it will take a long walk before I could make it happen.</p>

<p>If I'm wrong, please let me know. Or even better, send me a pull request!</p>

<p><big>What about preferences?</big></p>

<p>Another aspect of the project that I would like share is that it uses distroprefs to block Perl distribution to run in the smoker. Yes, you read it right.</p>

<p>Some distributions just bring the smoker down for different reasons. What makes me worried is that those distribution maintainers might not even know that those things happens.</p>

<p>The first problem is to communicate those issues. One thing that occurred me is that I could open a bug for the distribution, but that's a lot of work to do it manually by myself. The idea of distributions not being actively maintained surely also don't help.</p>

<p>What I did is to make those distroprefs <a href="https://github.com/glasswalk3r/cpan-openbsd-smoker/tree/master/prefs">available through the Github project</a>.</p>

<p>A nice this is that the distroprefs YAML format allows a comment to explain what is happening over there. I wish we could <a href="https://markmail.org/search/list:org.perl.cpan-testers-discuss#query:list%3Aorg.perl.cpan-testers-discuss%20from%3A%22Alceu%20Rodrigues%20de%20Freitas%20Junior%20via%20cpan-testers-discuss%22+page:2+mid:s73ttqc6tia6ed7t+state:results">selective choose which distribution not to install after testing</a>, but I guess is not possible right now.</p>

<p>In order to make it easier to maintain these files, I developed the CLI dblock (available in the CPAN-Reporter-Smoker-OpenBSD distribution, which I'm planning to migrate to it's own Git repository).</p>

<p>If there is a better way to manage those preferences and communicate with the distribution maintainers, please let me know.</p>

<p>Finally, if you want to release your distribution from the blockage, please let me know.</p>]]>
        
    </content>
</entry>
  <entry>
    <title>Scalar Context: Lists Versus Arrays</title>
    <link rel="alternate" href="http://blogs.perl.org/users/tom_wyant/2022/07/scalar-context-lists-versus-arrays.html"/>
    <id>tag:blogs.perl.org,2022:/users/tom_wyant//506.10848</id>
    <published>2022-07-12T23:54:31Z</published>
    <updated>2022-07-12T23:57:03Z</updated>
    <author>
        <name>Tom Wyant</name>
        
    </author>
    <content type="html" xml:lang="en" xml:base="http://blogs.perl.org/users/tom_wyant/">
        <![CDATA[<p>For a long time after I first encountered Perl, I looked on "list" and "array" as essentially interchangeable concepts. A list was simply the source construct corresponding to an array. This idea is <strong>mostly</strong> correct. But as they say, the devil is in the details.</p>

<p>One of the differences is what happens to them in scalar context. An array evaluates to the number of elements it contains. A list evaluates to its last element. So:</p>

<pre>
my @array = qw{ one two five };
say scalar @array;  # prints '3'
{
    no warnings 'void'; # Note the need for this
    say scalar( qw{ one two five } ); # prints 'five'
}
</pre>

<p>Okay, that is a trivial example. It becomes more interesting when you consider that subroutines inherit their calling context. If called in scalar context, a subroutine that returns a list behaves differently than one that returns an array:</p>

<pre>
sub array {
    state $array = [ qw{ one two five } ];
    return @{ $array };
}
sub list {
    return qw{ one two five };
}
say scalar array(); # prints 3
say scalar list();  # prints 'five';
</pre>

<p>Now, there is some sentiment against subroutines that "behave differently" in scalar and list context. Usually this is thought of in terms of the <a href="https://perldoc.perl.org/functions/wantarray"><code>wantarray()</code></a> built-in, and there is actually Perl Critic policy <a href="https://metacpan.org/pod/Perl::Critic::Policy::Community::Wantarray"><code>Perl::Critic::Community::WantArray</code></a> to flag these.</p>

<p>But it seems to me that any Perl subroutine that returns more than one value <strong>will</strong> behave differently in scalar context: it's just a question of whether you want the array behavior, the list behavior, or the arbitrary behavior you can get with <code>wantarray()</code>. The difference between good code and bad code is a matter of choosing this behavior carefully.</p>

<p>P.S.</p>

<p>What do you do if you have an array but want list behavior? There is no <code>list</code> built-in corresponding to the <code>scalar</code> built-in. The <a href="https://perldoc.perl.org/functions/scalar">documentation for <code>scalar</code></a> talks about this, but only addresses interpolation. In the general case, though, what seems to work is slicing the entire array:</p>

<pre>
say scalar @array[ 0 .. $#array ]; # prints 'five'
</pre>

<p>Or, if you want to encapsulate this behavior,</p>

<pre>
sub make_list { return @_[0..$#_] }
say scalar make_list( qw{ one two five } ); # prints 'five';
</pre>

<p>No, I did not come up with this on my own. I got it from <a href="https://stackoverflow.com/questions/34685788/convert-array-to-list">Stack Overflow</a>, specifically from <code>user2404501</code>'s response.</p>

<p>Be careful of getting too fancy with this. <code>scalar @array[ 0 .. $#array ]</code> is written <strong>much</strong> more clearly as <code>$array[-1]</code>.</p>
]]>
        
    </content>
</entry>
  <entry>
    <title>Perl Weekly Challenge 172: Prime Partition and Five-Number Summary </title>
    <link rel="alternate" href="http://blogs.perl.org/users/laurent_r/2022/07/perl-weekly-challenge-172-prime-partition-and-five-number-summary.html"/>
    <id>tag:blogs.perl.org,2022:/users/laurent_r//3226.10844</id>
    <published>2022-07-05T20:49:42Z</published>
    <updated>2022-07-11T01:47:09Z</updated>
    <author>
        <name>laurent_r</name>
        <uri>https://laurent-rosenfeld.developpez.com/</uri>
    </author>
    <content type="html" xml:lang="en" xml:base="http://blogs.perl.org/users/laurent_r/">
        <![CDATA[<p>These are some answers to the Week 172 of the <a href="https://perlweeklychallenge.org/blog/perl-weekly-challenge-172/">Perl Weekly Challenge</a> organized by <a href="http://blogs.perl.org/users/mohammad_s_anwar/">Mohammad S. Anwar</a>.</p>

<p><em>Spoiler Alert:</em> This weekly challenge deadline is due in a few of days from now (on July 10, 2022 at 23:59). This blog post offers some solutions to this challenge, please don’t read on if you intend to complete the challenge on your own.</p>

<h2>Task 1: Prime Partition</h2>

<p><em>You are given two positive integers, <code>$m</code> and <code>$n</code>.</em></p>

<p><em>Write a script to find out the Prime Partition of the given number. No duplicates allowed.</em></p>

<p><em>For example,</em></p>

<pre><code>Input: $m = 18, $n = 2
Output: 5, 13 or 7, 11

Input: $m = 19, $n = 3
Output: 3, 5, 11
</code></pre>

<p>The task description doesn&#8217;t say what a prime partition is. In mathematics, a partition of a positive integer <code>n</code> is usually a way of writing <code>n</code> as a sum of positive integers. We can assume that a <em>prime partition</em> is a partition made of only prime numbers. This is confirmed by the examples. From the examples, we can also infer that the second integer <code>$n</code> is the number of (prime) integers whose sum should be equal to <code>$m</code>. Also, the first example has two solutions (5, 13 <em>or</em> 7, 11). To me, this means that either solution is valid. So, I won&#8217;t bother to display all solutions when there is more than one, but will stop searching as soon as one solution has been found. Finally, since duplicates are not allowed, there will be some input values for which there is no solution. For example, for the input integers (17, 3): 17 could be considered as the sum of 3 primes, 13, 2, 2, but this isn&#8217;t a valid solution because of the duplicate 2 values. It is quite easy to check manually that there is no valid solution.</p>

<h3>Prime Partition in Raku</h3>

<p>We implement a recursive <code>partition</code> subroutine. If the second parameter (<code>$n</code>) is larger than 2, then <code>partition</code> subroutine loops through a list of prime number and calls itself recursively with a second parameter of <code>$n - 1</code>. If the second parameter is 2, then we stop recursion and find the solution (if any).</p>

<pre><code>my @primes = grep { .is-prime }, 1..100;
my %seen;

sub partition (Int $m, Int $n) {
    return if $n &lt; 2;
    if $n == 2 {
        for @primes -&gt; $i {
            last if $i &gt;= $m;
            my $j = $m - $i;
            next if $j == $i;
            next if %seen{$i} or %seen{$j};
            return $i, $j if $j.is-prime;
        }
        return;
    } else {
        for @primes -&gt; $i {
            last if $i &gt;= $m;
            %seen = $i =&gt; True;
            my @sub-partition = partition($m - $i, $n-1);
            next if @sub-partition.elems &lt; 2;
            return ($i, @sub-partition).flat;
        }
        return;
    }
}
for &lt;18 2&gt;, &lt;19 3&gt;, &lt;17 3&gt;, &lt;25 2&gt; -&gt; $test {
    my @partition = partition($test[0], $test[1]);
    say @partition.elems &lt; 2 ?? "$test: No solution" !! "Solution for $test: @partition[]";
}
</code></pre>

<p>With the four input tests provided, this program displays the following output:</p>

<pre><code>$ raku ./prime-partition.raku
Solution for 18 2: 5 13
Solution for 19 3: 3 5 11
17 3: No solution
Solution for 25 2: 2 23
</code></pre>

<p><em>Update July 05, 2022:</em> Shortly after I published this post earlier today, it occurred to me that there is a simpler way to do it, using the Raku built-in <a href="https://docs.raku.org/routine/combinations">combinations</a> routine:</p>

<pre><code>sub partition(Int $m, Int $n) {
    my $found = False;
    for (2..$m).grep({.is-prime}).combinations($n) -&gt; $comb {
        say "$m $n: ", $comb and $found = True if $comb.sum == $m;
    }
    say "$m $n: no solution " unless $found;
}
for &lt;18 2&gt;, &lt;19 3&gt;, &lt;17 3&gt;, &lt;25 2&gt; -&gt; $test {
    my @partition = partition($test[0], $test[1]);
}
</code></pre>

<p>This program displays the following output:</p>

<pre><code>$ ./raku prime-partition2.raku
18 2: (5 13)
18 2: (7 11)
19 3: (3 5 11)
17 3: no solution
25 2: (2 23)
</code></pre>

<p>Note that we are now displaying all solutions, not just the first one.</p>

<h3>Prime Partition in Perl</h3>

<p>This is a port to Perl of the first Raku program above. The only significant difference is that we had to implement our own <code>is_prime</code> subroutine.</p>

<pre><code>use strict;
use warnings;
use feature "say";

my @primes = grep { is_prime($_) } 1..100;
my %seen;

sub is_prime {
   my $n = shift;
   return 1 if $n == 2;
   return 0 if $n % 2 == 0;
   return 0 if $n == 1;
   my $p = 3;
   my $sqrt = sqrt $n;
   while ($p &lt;= $sqrt) {
       return 0 if $n % $p == 0;
       $p += 2;
   }
   return 1;
}

sub partition  {
    my ($m, $n) = @_;
    return if $n &lt; 2;
    if ($n == 2) {
        for my $i (@primes) {
            last if $i &gt;= $m;
            my $j = $m - $i;
            next if $j == $i;
            next if $seen{$i} or $seen{$j};
            return $i, $j if is_prime($j);
        }
        return;
    } else {
        for my $i (@primes) {
            last if $i &gt;= $m;
            %seen = ($i =&gt; 1);
            my @sub_partition = partition($m - $i, $n-1);
            next if @sub_partition &lt; 2;
            return ($i, @sub_partition);
        }
        return;
    }
}
for my $test ([18, 2], [19, 3], [17, 3], [25, 2]) {
    my @partition = partition(@$test);
    say @partition &lt; 2 ? "@$test: No solution" : "Solution for @$test: @partition";
}
</code></pre>

<p>This program displays the following results:</p>

<pre><code>$ perl ./prime-partition.pl
Solution for 18 2: 5 13
Solution for 19 3: 3 5 11
17 3: No solution
Solution for 25 2: 2 23
</code></pre>

<h3>Prime Partition in Julia</h3>

<p>In Julia, the <a href="http://juliamath.github.io/Primes.jl/v0.3/api.html#Primes.primes">Primes.primes</a> function returns an iterable collection of prime numbers. And the <a href="https://github.com/JuliaMath/Combinatorics.jl">Combinatoric</a> package provides the <code>combinations</code> function, which does exactly what its name implies. With thezse two functions, the solution is very simple:</p>

<pre><code>using Primes
using Combinatorics

function partition(m, n)
    for comb in combinations(primes(m),n)
        sum(comb) == m &amp;&amp; println("$m $n: ", comb)
    end
end

partition(18,2)
partition(19, 3)
partition(25, 2)
</code></pre>

<p>Output:</p>

<pre><code>$ julia ./prime-partition.jl
18 2: [5, 13]
18 2: [7, 11]## Task 2: Five-number Summary
19 3: [3, 5, 11]
25 2: [2, 23]*You are given an array of integers.*
</code></pre>

<h3>Prime Partition in Python</h3>

<p>Python also has <code>combinations</code> function, provided by the <code>itertools</code> package. We implement our own <code>is_prime</code> function.</p>

<pre><code>import math
from itertools import combinations

def is_prime(n):
  if n == 2:
    return True
  if n == 0 or n == 1 or n % 2 == 0:
    return False
  p = 3
  sqrt_n = math.sqrt(n)
  while (p &lt;= sqrt_n):
    if ((n % p) == 0):
      return False
    p += 2
  return True

def partition(m, n):
  primes = filter(is_prime, range (1, m))
  for combination in combinations(primes, n):
    if sum(combination) == m:
      print(m, n, ": ", combination)

partition(18, 2)
partition(19, 3)
partition(25, 2)
</code></pre>

<p>Output:</p>

<pre><code>$ python3 prime-partition.py
18 2 :  (5, 13)
18 2 :  (7, 11)
19 3 :  (3, 5, 11)
25 2 :  (2, 23)
</code></pre>

<h2>Task 2: Five-number Summary</h2>

<p><em>You are given an array of integers.</em></p>

<p><em>Write a script to compute the five-number summary of the given set of integers.</em></p>

<p><em>You can find the definition and example in the <a href="https://en.wikipedia.org/wiki/Five-number_summary">wikipedia page</a>.</em></p>

<p>The five-number summary is a set of descriptive statistics that provides information about a dataset. It consists of the five most important sample percentiles:</p>

<ul>
<li>the sample minimum (smallest observation)</li>
<li>the lower quartile or first quartile</li>
<li>the median (the middle value)</li>
<li>the upper quartile or third quartile</li>
<li>the sample maximum (largest observation)</li>
</ul>

<p>Intuitively, with a sorted data set, the <em>median</em> is the middle value separating the greater and lesser halves of the set. If the input set has an odd number of items, the median is the middle value. With an even number of items, the median is usually computed as the arithmetic mean of the two middle values. </p>

<p>The lower quartile or first quartile is the value such that one quarter (or 25%) of the items are smaller and three quarters (75%) are larger. It is the median of the lower half of the sorted dataset. And the upper or third quartile is the median of the upper half, i.e. a value such that three quarters are larger and one quarter larger. Having said that, I must add that, as often, the devil hides in the details. Depending on whether or not we include the median in the two halves, we might obtain different results, and there is no universal agreement on selecting the quartile values. This <a href="https://en.wikipedia.org/wiki/Quartile">Wikipedia page</a> lists four different methods for computing the quartiles (and, for some data sets, they will compute different results). So, it is sort of your draw, you may pick the method you prefer.</p>

<h3>Five-number Summary in Raku</h3>

<p>We implement a <code>median</code> subroutine to compute the median of a data set. As noted above, there are two formulas to compute the median, depending on whether the number of elements if even or odd. Note that our <code>median</code> subroutine relies on the fact that its input data has been previously sorted in ascending order (in the <code>summary</code> subroutine). Note that the <code>median</code> subroutine is used three times (to compute the median, or course, but also to compute the lower and upper quartiles).</p>

<p>The test data set is the set of observations of the number of moons for each planet in the solar system: <code>0, 0, 1, 2, 63, 61, 27, 13</code>, as provided in the <a href="https://en.wikipedia.org/wiki/Five-number_summary">Wikipedia page on the five-number summary</a>.</p>

<pre><code>sub median (@in) { # input values must have been sorted
    my $count = @in.elems;
    if $count %% 2 {
        return (@in[$count/2 -1] + @in[$count/2])/2;
    } else {
        return @in[($count - 1) / 2];
    }
}
sub summary (@input) {
    my @in = sort @input;
    my $min = @in[0];
    my $max = @in[*-1];
    my $median = median(@in);
    my $first-quart = median( grep { $_ &lt; $median}, @in);
    my $third-quart = median( grep { $_ &gt; $median}, @in);
    return $min, $first-quart, $median, $third-quart, $max;
}
my @moons = 0, 0, 1, 2, 63, 61, 27, 13;
say summary(@moons);
</code></pre>

<p>This program displays the following output:</p>

<pre><code>$ raku ./five-nums-summary.raku
(0 0.5 7.5 44 63)
</code></pre>

<h3>Five-number Summary in Perl</h3>

<p>This is a port to Perl of the Raku program just above. Please refer to the previous section for further explanations.</p>

<pre><code>use strict;
use warnings;
use feature "say";

sub median {
    my @in = @_; # Input values have been sorted previously
    my $count = scalar @in;
    if ($count % 2) {
        return $in[($count - 1) / 2];
    } else {
        return ($in[$count/2 -1] + $in[$count/2])/2;
    }
}
sub summary {
    my @in = sort { $a &lt;=&gt; $b } @_;
    my $min = $in[0];
    my $max = $in[-1];
    my $median = median(@in);
    my $first_quart = median( grep { $_ &lt; $median} @in);
    my $third_quart = median( grep { $_ &gt; $median} @in);
    return $min, $first_quart, $median, $third_quart, $max;
}
my @moons = (0, 0, 1, 2, 63, 61, 27, 13);
say join " ", summary(@moons);
</code></pre>

<p>This program displays the following output:</p>

<pre><code>$ perl ./five-nums-summary.pl
0 0.5 7.5 44 63
</code></pre>

<h3>Five-number Summary in Julia</h3>

<p>The <code>Statistics</code> package provides a number of functions, including <code>quantile</code> that we are using here:</p>

<pre><code>using Statistics

moons = sort([0, 0, 1, 2, 63, 61, 27, 13])

min = moons[1]  # Julia indices start at 1
first_quart = quantile(moons, 0.25)
median = quantile(moons, 0.5)
third_quart = quantile(moons, 0.75)
max = last(moons)

println("Min: $min; First quartile = $first_quart; Median: $median; Third quartile: $third_quart; Max: $max")
</code></pre>

<p>Output:</p>

<pre><code>$ julia ./five-nums-summary.jl
Min: 0; First quartile = 0.75; Median: 7.5; Third quartile: 35.5; Max: 63
</code></pre>

<h3>Five-number Summary in Python</h3>

<pre><code>def median(n):
  c = len(n)
  return n[int((c - 1) / 2)] if c % 2 != 0 else (n[int(c/2 -1)] + n[int(c/2)])/2


def summary(input):
  min = input[0]
  max = input[-1]
  med = median(input)
  lower_half = list(filter(lambda p: p &lt; med, input))
  # print(lower_half)
  first_quart = median(lower_half)
  third_quart = median(list(filter(lambda p: p &gt; med, input)))
  return(min, first_quart, med, third_quart, max)

moons = sorted([0, 0, 1, 2, 63, 61, 27, 13])
print(summary(moons));
</code></pre>

<p>Output:</p>

<pre><code>$ python3 ./five-nums-summary.py
(0, 0.5, 7.5, 44.0, 63)
</code></pre>

<h3>Five-number Summary in Ruby</h3>

<pre><code>def median(n)
    size = n.length
    if size %2 != 0
        n[(size + 1) / 2] 
    else
        (n[size/2] + n[size/2 + 1]) / 2.0
    end
end

def summary(n)
    min = n[0]
    max = n[-1]
    med = median(n)
    first_q = median( n.select { |i| i &lt; med })
    last_q = median( n.select { |i| i &gt; med })
    return min, first_q, med, last_q, max
end

moons = [0, 0, 1, 2, 63, 61, 27, 13]
print summary(moons.sort), "\n"
</code></pre>

<p>Output:</p>

<pre><code>[0, 0.5, 7.5, 44.0, 63]
</code></pre>

<h3>Five-number Summary in C</h3>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int compare_int(const void *a,const void *b) {
    int *x = (int *) a;
    int *y = (int *) b;
    return *x - *y;
}

float median (int count, int m[]) {
    if (count % 2) {
        return 1.0 * m[(count -1)/2];
    } else {
        return (m[count/2 -1] + m[count/2])/2.0;
    }
}

int main() {
    int moons[] = {0, 0, 1, 2, 63, 61, 27, 13};
    int size = sizeof(moons)/sizeof(*moons);
    qsort (moons, size, sizeof(*moons), compare_int);
    float min = 1.0 * moons[0];
    float med = median(size, moons);
    int half = (int)size/2;
    float first_q = median(half, moons);
    float last_q = median(half, moons + 4);
    float max = 1.0 * moons[size - 1];
    printf ("%.2f %.2f %.2f %.2f %.2f", min, first_q, med, last_q, max);
    return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>0.00 0.50 7.50 44.00 63.00
</code></pre>

<h3>Five-number Summary in Ring</h3>

<p>Ring does not seem to have a filter (or <code>grep</code>) function and also doesn&#8217;t seem to have array slices. Or, if it has any of these two features, I did not find them in the documentation. In addition, Ring array indices start with 1. So, I managed manually the various ranges, but I must admit that, being used with array indices starting at 0, it took me quite a while to get the array index computations right. </p>

<pre><code>moons = [0, 0, 1, 2, 63, 61, 27, 13]
see summary(sort(moons))

func summary(n)
    min = n[1]
    max = n[len(n)]
    size = len(n)
    med = median(1, size, n)
    first_q =  median(1, size/2, n)
    last_q = median(size/2 +1, size, n)
    return [min, first_q, med, last_q, max]

func median(low, high, n)
    if (high + low) % 2 = 0 
        return n[low + (high - low + 1)/2]
    else
        return (n[low + (high - low + 1)/2] + n[low + (high - low + 1)/2 - 1]) / 2.0
    ok
</code></pre>

<p>Output:</p>

<pre><code>0
0.50
7.50
44
63
</code></pre>

<h2>Wrapping up</h2>

<p>The next week Perl Weekly Challenge will start soon. If you want to participate in this challenge, please check https://perlweeklychallenge.org/ and make sure you answer the challenge before 23:59 BST (British summer time) on July 17, 2022. And, please, also spread the word about the Perl Weekly Challenge if you can.</p>
]]>
        

    </content>
</entry>
  <entry>
    <title>Partition the Summary</title>
    <link rel="alternate" href="http://www.rabbitfarm.com/cgi-bin/blosxom/2022/07/10#pwc172" type="text/html"/>
    <content type="html">
&lt;p&gt;&lt;em&gt;The examples used here are from the weekly challenge problem statement and demonstrate 
the working solution.&lt;/em&gt;&lt;/p&gt;

&lt;h2&gt;Part 1&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;You are given two positive integers, $n and $k. Write a script to find out the Prime 
Partition of the given number. No duplicates are allowed.&lt;/em&gt;&lt;/p&gt;

&lt;h3&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class="perl"&gt;
use strict;
use warnings;
use boolean;
use Math::Combinatorics;

sub sieve_atkin{
    my($upper_bound) = @_;
    my @primes = (2, 3, 5);
    my @atkin = (false) x $upper_bound;    
    my @sieve = (1, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 49, 53, 59);
    for my $x (1 .. sqrt($upper_bound)){
        for(my $y = 1; $y &lt;= sqrt($upper_bound); $y+=2){
            my $m = (4 * $x ** 2) + ($y ** 2);
            my @remainders;  
            @remainders = grep {$m % 60 == $_} (1, 13, 17, 29, 37, 41, 49, 53) if $m &lt;= $upper_bound; 
            $atkin[$m] = !$atkin[$m] if @remainders; 
        }          
    } 
    for(my $x = 1; $x &lt;= sqrt($upper_bound); $x += 2){
        for(my $y = 2; $y &lt;= sqrt($upper_bound); $y += 2){
            my $m = (3 * $x ** 2) + ($y ** 2);
            my @remainders;  
            @remainders = grep {$m % 60 == $_} (7, 19, 31, 43) if $m &lt;= $upper_bound; 
            $atkin[$m] = !$atkin[$m] if @remainders; 
        }          
    }   
    for(my $x = 2; $x &lt;= sqrt($upper_bound); $x++){
        for(my $y = $x - 1; $y &gt;= 1; $y -= 2){
            my $m = (3 * $x ** 2) - ($y ** 2);
            my @remainders;  
            @remainders = grep {$m % 60 == $_} (11, 23, 47, 59) if $m &lt;= $upper_bound; 
            $atkin[$m] = !$atkin[$m] if @remainders; 
        }          
    } 
    my @m;
    for my $w (0 .. ($upper_bound / 60)){
        for my $s (@sieve){
            push @m, 60 * $w + $s;  
        }
    }
    for my $m (@m){
        last if $upper_bound &lt; ($m ** 2);
        my $mm = $m ** 2;
        if($atkin[$m]){
            for my $m2 (@m){
                my $c = $mm * $m2;
                last if $c &gt; $upper_bound;
                $atkin[$c] = false;
            }
        }
    }
    map{ push @primes, $_ if $atkin[$_] } 0 .. @atkin - 1;
    return @primes; 
}

sub prime_partition{
    my($n, $k) = @_;
    my @partitions;
    my @primes = sieve_atkin($n);
    my $combinations = Math::Combinatorics-&gt;new(count =&gt; $k, data =&gt; [@primes]);
    while(my @combination = $combinations-&gt;next_combination()){
        push @partitions, [@combination] if unpack("%32I*", pack("I*", @combination)) == $n;
    }
    return @partitions;
}

MAIN:{
    my($n, $k);
    $n = 18, $k = 2;
    map{ 
        print "$n = " . join(", ", @{$_}) . "\n"
    } prime_partition($n, $k);
    print"\n\n";
    $n = 19, $k = 3;
    map{ 
        print "$n = " . join(", ", @{$_}) . "\n"
    } prime_partition($n, $k);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Sample Run&lt;/h3&gt;

&lt;pre&gt;&lt;code class="shell"&gt;
$ perl perl/ch-1.pl
18 = 7, 11
18 = 5, 13


19 = 3, 11, 5
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Notes&lt;/h3&gt;

&lt;p&gt;Only when writing this short blog did I realize there is a far more efficient way of 
doing this!&lt;/p&gt;

&lt;p&gt;Here we see a brute force exhaustion of all possible combinations. This works alright for 
when &lt;code&gt;$n&lt;/code&gt; and &lt;code&gt;$k&lt;/code&gt; are relatively small. For larger values a procedure like this would be
better,&lt;/p&gt;

&lt;pre&gt;
1. Obtain all primes $p &lt; $n
2. Start with $n and compute $m = $n - $p for all $p
3. If $m is prime and $k = 2 DONE
4. Else set $n = $m and repeat, computing a new $m with all $p &lt; $m stopping with the same criteria if $m is prime and $k is satisfied
&lt;/pre&gt;

&lt;p&gt;This procedure would be a natural fit for recursion, if you were in the mood for that sort 
of thing.&lt;/p&gt;

&lt;h2&gt;Part 2&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;You are given an array of integers. Write a script to compute the five-number summary of 
the given set of integers.&lt;/em&gt;&lt;/p&gt;

&lt;h3&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class="perl"&gt;
use strict;
use warnings;
sub five_number_summary{
    my @numbers = @_;
    my($minimum, $maximum, $first_quartile, $median, $third_quartile);
    my @sorted = sort {$a &lt;=&gt; $b} @numbers;
    $minimum = $sorted[0];
    $maximum = $sorted[@sorted - 1];
    if(@sorted % 2 == 0){
        my $median_0 = $sorted[int(@sorted / 2) - 1];
        my $median_1 = $sorted[int(@sorted / 2)];
        $median = ($median_0 + $median_1) / 2;
        my @lower_half = @sorted[0 .. int(@sorted / 2)];
        my $median_lower_0 = $lower_half[int(@lower_half / 2) - 1];
        my $median_lower_1 = $lower_half[int(@lower_half / 2)];
        $first_quartile = ($median_lower_0 + $median_lower_1) / 2;       
        my @upper_half = @sorted[int(@sorted / 2) .. @sorted];
        my $median_upper_0 = $upper_half[int(@upper_half / 2) - 1];
        my $median_upper_1 = $upper_half[int(@upper_half / 2)];
        $third_quartile = ($median_upper_0 + $median_upper_1) / 2;
    }
    else{
        $median = $sorted[int(@sorted / 2)];
        $first_quartile = [@sorted[0 .. int(@sorted / 2)]]-&gt;[int(@sorted / 2) / 2];
        $third_quartile = [@sorted[int(@sorted / 2) .. @sorted]]-&gt;[(@sorted - int(@sorted / 2)) / 2];
    }
    return {
        minimum =&gt; $minimum, 
        maximum =&gt; $maximum, 
        first_quartile =&gt; $first_quartile, 
        median =&gt; $median, 
        third_quartile =&gt; $third_quartile
    };
}

MAIN:{
    my @numbers;
    my $five_number_summary;
    @numbers = (6, 3, 7, 8, 1, 3, 9);
    print join(", ", @numbers) . "\n";
    $five_number_summary = five_number_summary(@numbers);
    map{
        print "$_: $five_number_summary-&gt;{$_}\n";
    } keys %{$five_number_summary};
    print "\n\n";
    @numbers = (2, 6, 3, 8, 1, 5, 9, 4);
    print join(", ", @numbers) . "\n";    
    $five_number_summary = five_number_summary(@numbers);
    map{
        print "$_: $five_number_summary-&gt;{$_}\n";
    } keys %{$five_number_summary};
    print "\n\n";
    @numbers = (1, 2, 2, 3, 4, 6, 6, 7, 7, 7, 8, 11, 12, 15, 15, 15, 17, 17, 18, 20);
    print join(", ", @numbers) . "\n";      
    $five_number_summary = five_number_summary(@numbers);
    map{
        print "$_: $five_number_summary-&gt;{$_}\n";
    } keys %{$five_number_summary};
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Sample Run&lt;/h3&gt;

&lt;pre&gt;&lt;code class="shell"&gt;
$ perl perl/ch-2.pl
6, 3, 7, 8, 1, 3, 9
third_quartile: 8
maximum: 9
minimum: 1
first_quartile: 3
median: 6


2, 6, 3, 8, 1, 5, 9, 4
median: 4.5
first_quartile: 2.5
minimum: 1
maximum: 9
third_quartile: 7


1, 2, 2, 3, 4, 6, 6, 7, 7, 7, 8, 11, 12, 15, 15, 15, 17, 17, 18, 20
maximum: 20
third_quartile: 15
first_quartile: 5
median: 7.5
minimum: 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Notes&lt;/h3&gt;

&lt;p&gt;Note that the case of an even or odd number of elements of the list (and sublists) 
requires slightly special handling.&lt;/p&gt;

&lt;h2&gt;References&lt;/h2&gt;

&lt;p&gt;&lt;a href="https://theweeklychallenge.org/blog/perl-weekly-challenge-172/"&gt;Challenge 172&lt;/a&gt;&lt;/p&gt;</content>
    <id>http://www.rabbitfarm.com/cgi-bin/blosxom/perl/pwc172</id>
    <published>2022-07-10T20:39:00-04:00</published>
    <updated>2022-07-10T20:39:00-04:00</updated>
    <category term="/perl"/>
  </entry>
  <entry>
    <title>Abundant Composition</title>
    <link rel="alternate" href="http://www.rabbitfarm.com/cgi-bin/blosxom/2022/07/03#pwc171" type="text/html"/>
    <content type="html">
&lt;p&gt;&lt;em&gt;The examples used here are from the weekly challenge problem statement and demonstrate 
the working solution.&lt;/em&gt;&lt;/p&gt;

&lt;h2&gt;Part 1&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Write a script to generate the first twenty Abundant Odd Numbers.&lt;/em&gt;&lt;/p&gt;

&lt;h3&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class="perl"&gt;
use strict;
use warnings;
sub proper_divisors{
    my($n) = @_;
    my @divisors;
    for my $x (1 .. $n / 2){
        push @divisors, $x if $n % $x == 0;
    }
    return @divisors;
}

sub n_abundant_odd{
    my($n) = @_; 
    my $x = 0;
    my @odd_abundants;
    {
        push @odd_abundants, $x if $x % 2 == 1 &amp;&amp; unpack("%32I*", pack("I*", proper_divisors($x))) &gt; $x;
        $x++;
        redo if @odd_abundants &lt; $n;
    }
    return @odd_abundants;
}

MAIN:{
    print join(", ", n_abundant_odd(20)) . "\n";
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Sample Run&lt;/h3&gt;

&lt;pre&gt;&lt;code class="shell"&gt;
$ perl perl/ch-1.pl
945, 1575, 2205, 2835, 3465, 4095, 4725, 5355, 5775, 5985, 6435, 6615, 6825, 7245, 7425, 7875, 8085, 8415, 8505, 8925
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Notes&lt;/h3&gt;

&lt;p&gt;The solution here incorporated a lot of elements from previous weekly challenges. That is 
to say it is quite familiar, I continue to be a fan of &lt;code&gt;redo&lt;/code&gt; as well as the &lt;code&gt;pack/unpack&lt;/code&gt;
method of summing the elements of an array.&lt;/p&gt;

&lt;h2&gt;Part 2&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Create sub compose($f, $g) which takes in two parameters $f and $g as subroutine refs 
and returns subroutine ref i.e. compose($f, $g)-&gt;($x) = $f-&gt;($g-&gt;($x)).&lt;/em&gt;&lt;/p&gt;

&lt;h3&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class="perl"&gt;
use strict;
use warnings;
sub f{
    my($x) = @_;
    return $x + $x;
}

sub g{
    my($x) = @_;
    return $x * $x;
}

sub compose{
    my($f, $g) = @_;
    return sub{
        my($x) = @_;
        return $f-&gt;($g-&gt;($x));
    };
}

MAIN:{
    my $h = compose(\&amp;f, \&amp;g);
    print $h-&gt;(7) . "\n";
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Sample Run&lt;/h3&gt;

&lt;pre&gt;&lt;code class="shell"&gt;
$ perl perl/ch-2.pl
98
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Notes&lt;/h3&gt;

&lt;p&gt;This problem incorporates some interesting concepts, especially from functional 
programming. Treating functions in a &lt;em&gt;first class way&lt;/em&gt;, that is, passing them as 
parameters, manipulating them, dynamically generating new ones are commonly performed in
functional programming languages such as Lisp and ML. Here we can see that Perl can quite
easily do these things as well!&lt;/p&gt;

&lt;h2&gt;References&lt;/h2&gt;

&lt;p&gt;&lt;a href="https://theweeklychallenge.org/blog/perl-weekly-challenge-171/"&gt;Challenge 171&lt;/a&gt;&lt;/p&gt;</content>
    <id>http://www.rabbitfarm.com/cgi-bin/blosxom/perl/pwc171</id>
    <published>2022-07-03T12:39:00-04:00</published>
    <updated>2022-07-03T12:39:00-04:00</updated>
    <category term="/perl"/>
  </entry>
  <entry>
    <title>Brilliantly Discover Achilles' Imperfection</title>
    <link rel="alternate" href="http://www.rabbitfarm.com/cgi-bin/blosxom/2022/06/19#pwc169" type="text/html"/>
    <content type="html">
&lt;p&gt;&lt;em&gt;The examples used here are from the weekly challenge problem statement and demonstrate 
the working solution.&lt;/em&gt;&lt;/p&gt;

&lt;h2&gt;Part 1&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Write a script to generate the first 20 Brilliant Numbers.&lt;/em&gt;&lt;/p&gt;

&lt;h3&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class="perl"&gt;
use strict;
use warnings;
sub prime_factor{
    my $x = shift(@_); 
    my @factors;    
    for(my $y = 2; $y &lt;= $x; $y++){
        next if $x % $y;
        $x /= $y;
        push @factors, $y;
        redo;
    }
    return @factors;  
}

sub is_brilliant{
    my($n) = @_;
    my @factors = prime_factor($n); 
    return @factors == 2 &amp;&amp; length($factors[0]) == length($factors[1]);
}

sub n_brilliants{
    my($n) = @_;
    my @brilliants;
    my $i = 0;
    {
       push @brilliants, $i if is_brilliant($i);
       $i++;
       redo if @brilliants &lt; $n;
    }
    return @brilliants;
}

MAIN:{
    print join(", ", n_brilliants(20)) . "\n";
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Sample Run&lt;/h3&gt;

&lt;pre&gt;&lt;code class="shell"&gt;
$ perl perl/ch-1.pl
4, 6, 9, 10, 14, 15, 21, 25, 35, 49, 121, 143, 169, 187, 209, 221, 247, 253, 289, 299
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Notes&lt;/h3&gt;

&lt;p&gt;The solution here incorporated a lot of elements from previous weekly challenges. That is 
to say it is quite familiar, I continue to be a fan of &lt;code&gt;redo&lt;/code&gt;!&lt;/p&gt;

&lt;h2&gt;Part 2&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Write a script to generate the first 20 Achilles Numbers.&lt;/em&gt;&lt;/p&gt;

&lt;h3&gt;Solution&lt;/h3&gt;

&lt;pre&gt;&lt;code class="perl"&gt;
use strict;
use warnings;
use POSIX;
use boolean;

sub prime_factor{
    my $x = shift(@_); 
    my @factors;    
    for (my $y = 2; $y &lt;= $x; $y++){
        next if $x % $y;
        $x /= $y;
        push @factors, $y;
        redo;
    }
    return @factors;  
}

sub is_achilles{
    my($n) = @_;
    my @factors = prime_factor($n); 
    for my $factor (@factors){
        return false if $n % ($factor * $factor) != 0;
    }
    for(my $i = 2; $i &lt;= sqrt($n); $i++) {
        my $d = log($n) / log($i) . "";
        return false if ceil($d) == floor($d);  
    }
    return true;
}

sub n_achilles{
    my($n) = @_;
    my @achilles;
    my $i = 1;
    {
       $i++;
       push @achilles, $i if is_achilles($i);
       redo if @achilles &lt; $n;
    }
    return @achilles;
}

MAIN:{
    print join(", ", n_achilles(20)) . "\n";
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Sample Run&lt;/h3&gt;

&lt;pre&gt;&lt;code class="shell"&gt;
$ perl perl/ch-2.pl
72, 108, 200, 288, 392, 432, 500, 648, 675, 800, 864, 968, 972, 1125, 1152, 1323, 1352, 1372, 1568, 1800
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Notes&lt;/h3&gt;

&lt;p&gt;This problem revealed something interesting with how, apparently, certain functions will
handle integer and floating point values. The issue arises when we are computing 
logarithms. We can see the issue in isolation in a one liner.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;perl -MPOSIX -e '$d = log(9) / log(3); print ceil($d) . "\t" . floor($d) . "\t$d\n"'&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;which prints &lt;code&gt;3       2       2&lt;/code&gt;. Notice that &lt;code&gt;log(9) / log(3)&lt;/code&gt; is exactly &lt;code&gt;2&lt;/code&gt; but, ok, 
floating point issues maybe it is 2.0000000001 and &lt;code&gt;ceil&lt;/code&gt; will give 3. 
But why does this work?&lt;/p&gt;

&lt;p&gt;&lt;code&gt;perl -MPOSIX -e '$d = sqrt(9); print ceil($d) . "\t" . floor($d) . "\t$d\n"'&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;which gives &lt;code&gt;3       3       3&lt;/code&gt;. I am not sure what sqrt is doing differently? I guess 
how it stores the result internally? By the way, I am doing this to check is the result is 
an integer. That is if ceil($x) == floor($x), but that isn't working here as expected but 
I have used that trick in the past. I guess only with sqrt in the past though so never 
encountered this.&lt;/p&gt;

&lt;p&gt;The trick to work around this, in the solution to the challenge is like this:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;perl -MPOSIX -e '$d = log(9) / log(3)  . ""; print ceil($d) . "\t" . floor($d) . "\t$d\n"'&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;this does what I want and gives &lt;code&gt;2       2       2&lt;/code&gt;. I guess that drops the 
infinitesimally small decimal part when concatenating and converting to a string which 
stays gone when used numerically? &lt;/p&gt;

&lt;p&gt;Of course, there are other ways to do this. For example &lt;code&gt;abs($x - int(x)) &amp;lt; 1e-7&lt;/code&gt; will 
ensure that, within a minuscule rounding error, &lt;code&gt;$x&lt;/code&gt; is an integer.&lt;/p&gt;

&lt;h2&gt;References&lt;/h2&gt;

&lt;p&gt;&lt;a href="https://theweeklychallenge.org/blog/perl-weekly-challenge-169/"&gt;Challenge 169&lt;/a&gt;&lt;/p&gt;</content>
    <id>http://www.rabbitfarm.com/cgi-bin/blosxom/perl/pwc169</id>
    <published>2022-06-19T12:39:00-04:00</published>
    <updated>2022-06-19T12:39:00-04:00</updated>
    <category term="/perl"/>
  </entry>
</feed>
